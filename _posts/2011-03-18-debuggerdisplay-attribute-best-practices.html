<p>The <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.debuggerdisplayattribute.aspx">DebuggerDisplayAttribute</a> is a powerful way to customize the way values are displayed at debug time.&#160; Instead of getting a simple type name display, interesting fields, properties or even custom strings can be surfaced to the user in useful combinations</p>  <pre class="code">[<span style="color: #2b91af">DebuggerDisplay</span>(<span style="color: #a31515">&quot;Student: {FirstName} {LastName}&quot;</span>)]
<span style="color: blue">public sealed class </span><span style="color: #2b91af">Student </span>{
    <span style="color: blue">public string </span>FirstName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>LastName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>


<p>The DebuggerDisplay attribute can customize the name, value and type columns in the debugger window.&#160; Each one can be customized using a string which can contain constant text or expressions to be be evaluated by the expression evaluator.&#160; The latter is designated by putting the expression inside {}’s (this greatly resembles String.Format)</p>

<p>This feature while very powerful and useful can also easily contribute negatively to the debugging experience when used improperly (mostly in the area of performance).&#160; After several years of working in this area and helping customers out with bugs I’ve come up with a few recommendations to help prevent this from happening [1]</p>

<h2>Don’t use multiple functions or properties in the display string</h2>

<p>Every time I see a DebuggerDisplay attribute like the following I cringe a little inside</p>

<pre class="code">[<span style="color: #2b91af">DebuggerDisplay</span>(<span style="color: #a31515">&quot;Student: {FirstName} {LastName} {Age} {Birthday} {Address}&quot;</span>)]</pre>


<p>Hands down the most expensive operation the expression evaluator does is evaluate a function.&#160; It dwarfs every other performance metric and can have a visible effect on stepping performance [2].&#160;&#160; This is true for both functions and properties (as far as the debugger is concerned there is almost no difference between the two).&#160; </p>

<p>Every one of the expression holes above results in a property being evaluated.&#160; Each property must be evaluated individually and done so once for every instance of this type in every debugger display window.&#160; This set of evaluations is repeated on every single step.&#160; This can get very expensive if collections of this type end up getting displayed (imagine stepping with a couple thousand of these in the window!).&#160; </p>

<p>Please don’t read this and remove every property from DebuggerDisplay’s in your code.&#160; One property is very unlikely to cause a problem.&#160; Issues typically arise when many properties are used and collections of that type end getting displayed in the debugger windows.&#160; </p>

<h2>Do use property / field names instead of language specific expressions</h2>

<p>Evaluation holes in the string are not limited to just properties and function calls.&#160; They can handle pretty much any legal expression you can dream up.&#160; In the past this has lead to developers putting all manner of expressions into DebuggerDisplay attributes.&#160; The most common being the use of ternary expressions</p>

<pre class="code">[<span style="color: #2b91af">DebuggerDisplay</span>(<span style="color: #a31515">&quot;Count {IsEmpty ? 0 : Count}&quot;</span>)]</pre>


<p>While this works fine, please don’t do this!&#160; DebuggerDisplay attributes are evaluated not by the language in which they were defined but by the expression evaluator of the language in which they are being used.&#160; The above works great but only when viewed in a C# application.&#160; It fails miserably when viewed in other languages like VB.Net (and when F# has their own EE it will fail for that as well).&#160; </p>

<p>While there is no truly universal expression one which is supported by most languages is member names.&#160; Having an expression which is a simple property or field goes a long way to removing this problem.&#160; </p>

<h2>Don’t evaluate expressions that throw exceptions</h2>

<p>Earlier I mentioned that the most expensive action an expression evaluator performs is evaluating a function.&#160; The most expensive variant of evaluating a function are those which throw exceptions.&#160; Please don’t do this.&#160; </p>

<h2>Don’t use mutating properties or functions</h2>

<p>Usually this goes without saying but I’ve seen enough examples of this to warrant an entry.&#160; Don’t put expressions into DebuggerDisplay values which will mutate the underlying value.&#160; This will lead to only confusion. </p>

<h2>Preferred Pattern </h2>

<p>My personal preferred pattern for DebuggerDisplay attributes is to have the entire item be an expression: DebuggerDisplay.&#160; I then add a private instance property to my type named DebuggerDisplay and do all of my custom formatting in this property.&#160; Having the property be private is fine because <a href="http://blogs.msdn.com/b/jaredpar/archive/2010/05/17/the-debugger-is-different.aspx">nothing is private in the debugger.</a></p>

<pre class="code">[<span style="color: #2b91af">DebuggerDisplay</span>(<span style="color: #a31515">&quot;{DebuggerDisplay,nq}&quot;</span>)]
<span style="color: blue">public sealed class </span><span style="color: #2b91af">Student </span>{
    <span style="color: blue">public string </span>FirstName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>LastName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">private string </span>DebuggerDisplay {
        <span style="color: blue">get </span>{ <span style="color: blue">return string</span>.Format(<span style="color: #a31515">&quot;Student: {0} {1}&quot;</span>, FirstName, LastName); }
    }
}</pre>

<p>The “,nq” suffix here just asks the expression evaluator to remove the quotes when displaying the final value (nq = no quotes).&#160; </p>

<p>I prefer this pattern because it’s only requires a single function to be evaluated, I can still have language specific expressions (which are nicely type checked by the compiler) and it doesn’t contribute to the public API of my type.&#160; </p>

<p>[1] Note the word “I”.&#160; These are not any kind of official recommendations, just several I advocate to people using this feature. </p>

<p>[2] In one performance critical scenario for Visual Studio 2010 over 95% of it was spent evaluating the function!&#160; </p><div style="clear:both;"></div></div>
    