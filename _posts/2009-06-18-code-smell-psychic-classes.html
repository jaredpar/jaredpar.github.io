<p>Psychic classes have the appearance of ignoring data provided to it in an attempt to provide you with an answer they predict is better for the situation.&#160;&#160; It’s impossible to look at a the data provided to an instance of the class and understand what queries on the object will return because it may think of a better answer for you, or a better piece of data to look at.</p>  <p>This comes from an example I ran into about a month ago.&#160; I work on an IDE and naturally deal with a lot of parse trees and tokens.&#160; Parsing everything all the time is expensive so naturally the results are cached in various places for performance reasons.&#160; </p>  <p>While debugging one such cache I noticed some strange behavior.&#160; The cache wasn’t returning the right tree for the input it was provided.&#160; So I decided to dig into the code a bit.&#160; </p>  <p>This cache takes several different forms of input which has no common base class or interface.&#160; What I noticed though is that when resetting the input of the service, it would not clear the existing cache or the previous form of input.&#160; Also because of the way the code loaded certain forms of input had precedence over others.&#160; So even an explicit clear did not guarantee the “correct” input was used.</p>  <p>The result is a service that reads well in code, but will not always act as you expect it to.&#160; The service at times will seemingly ignore all input and pick a source it thinks is better.&#160; Take the following code as an example</p>  <pre>pCache-&gt;SetSource(pSomeFile);
ParseTree* pTree = pCache-&gt;GetTree();  </pre>

<p>This code is very straight forward but is certainly not guaranteed to do what it appears to do. </p>

<p>I like to think the service is predicting the results rather than calculating them.&#160; Or better yet guessing the answer.&#160; From the perspective of a code reviewer, that’s what’s happening.&#160; </p>

<p>Obviously I was curious about the reason for this and did a bit of research.&#160; It’s a rather old class so I had to contact people who’d been on the team awhile back and dig through the history of the code base to understand what the purpose of this behavior was.&#160; It turns out it was done to fix a few impactful scenarios where an alternate source needed precedence over the typical source.&#160; Other devs didn’t fully understand the source semantics of the service and wrote methods that caused bad interactions.&#160; Eventually it evolved to it’s current odd state.&#160; </p>

<p>Thanks to <a href="http://diditwith.net/">Dustin</a> for coining the term “psychic classes”.&#160; Other ones we considered were</p>

<ul>
  <li>Jedi Mind Trick classes: Weak name</li>

  <li>Weatherman: It’s a prediction after all&#160; </li>
</ul>

<p>And yes, we fixed this issue :) </p></div>
    