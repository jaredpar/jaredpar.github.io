<p>Now we have a decent tuple generation script which produces a very usable set of tuple classes.&nbsp; After awhile I ended up getting stuck because the tuples are not flexible enough.&nbsp; It's not possible to use a 2 pair tuple where a 1 pair is expected even though it meets the requirements.&nbsp; </p><pre class="code">            Process(<span style="color: rgb(43,145,175)">Tuple</span>.Create(<span style="color: rgb(163,21,21)">"foo"</span>));
            Process(<span style="color: rgb(43,145,175)">Tuple</span>.Create(<span style="color: rgb(163,21,21)">"foo"</span>, 42));

        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> Process&lt;TA&gt;(<span style="color: rgb(43,145,175)">ITuple</span>&lt;TA&gt; tuple)
        {
            
        }</pre><a href="http://11011.net/software/vspaste"></a>
<p>I considered two approaches to this problem; inheritance and interface.&nbsp; I debated the inheritance one for awhile.&nbsp; I couldn't convince myself one way or another if a Tuple&lt;int,int&gt; was a Tuple&lt;int&gt; or merely behaved like one.&nbsp; Also once we introduce a MutableTuple class inheritance won't fix the problem (unless you introduce nasty shadowing variables).&nbsp; Instead I opted for an interface based approach.&nbsp; </p>
<p>In addition to defining the basic interface I added two methods to the base most interface.&nbsp; These methods allow methods to operate on tuples in generic ways regardless of the pair count.&nbsp; </p><pre class="code">    <span style="color: rgb(0,0,255)">int</span> Count { <span style="color: rgb(0,0,255)">get</span>; }
    <span style="color: rgb(0,0,255)">object</span> <span style="color: rgb(0,0,255)">this</span>[<span style="color: rgb(0,0,255)">int</span> index] { <span style="color: rgb(0,0,255)">get</span>; }</pre>
<p>Generating the implementation is straight forward at this point considering the past solutions.&nbsp; You'll also have to alter the class definition to inherit from the appropriate ITuple interface.&nbsp; </p>
<p>Hopefully by now it's becoming clear why having a script to regenerate the large code base is a good idea.&nbsp; It's easy to make sweeping changes to your implementation.</p>
<p>function script:Gen-ITuple <br>{ <br>&nbsp;&nbsp;&nbsp; param ( [int] $count = $(throw "Need a count") ) <br>&nbsp;&nbsp;&nbsp; $OFS = ',' <br>&nbsp;&nbsp;&nbsp; $gen = "&lt;" + [string](0..($count-1) | %{ "T"+$upperList[$_] }) + "&gt;"&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; $base = "" <br>&nbsp;&nbsp;&nbsp; if ( $count -ne 1 ) <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $baseGen = "&lt;" + [string](0..($count-2) | %{ "T"+$upperList[$_] }) + "&gt;"&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $base = ": ITuple$baseGen" <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $base = ": ITuple" <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; "public interface ITuple$gen $base {" <br>&nbsp;&nbsp;&nbsp; "T{0} {0} {{ get; }}" -f $upperList[$count-1]&nbsp; <br>&nbsp;&nbsp;&nbsp; "}" <br>} </p>
<p>function script:Gen-TupleAccess <br>{ <br>&nbsp;&nbsp;&nbsp; param ( [int] $count = $(throw "Need a count") ) <br>&nbsp;&nbsp;&nbsp; "public int Count { get { return $count; } }" <br>&nbsp;&nbsp;&nbsp; "public object this[int index] { get { switch (index){ " <br>&nbsp;&nbsp;&nbsp; 0..($count-1) | %{ "case $($_): return m_$($lowerList[$_]);" } <br>&nbsp;&nbsp;&nbsp; "default: throw new InvalidOperationException(""Bad Index"");" <br>&nbsp;&nbsp;&nbsp; "} } }" <br>}</p></div>
    