<P>This is part&nbsp;3 of a series.&nbsp; You can find <A href="http://blogs.msdn.com/jaredpar/archive/2005/07/11/437584.aspx" mce_href="http://blogs.msdn.com/jaredpar/archive/2005/07/11/437584.aspx"><STRONG><FONT color=#006bad>part one here</FONT></STRONG></A>.&nbsp; Please refer to that article for all of the Native definitions of the structures that I use here.</P>
<P>In part 2 of this series I demonstrated how you can Marshal nested data structures by flattening an array of structures into it's individual elements.&nbsp; Using this is very awkward and is only practical when the size of your array is small.&nbsp; This installment will get around these limitations with a bit of Marshalling help.&nbsp; We'll get back indexing and remove the awkward flattening.</P>
<P>Once again, don't forget that the only 2 things that matter when Marshalling data</P>
<OL>
<LI>Byte Size 
<LI>Byte Layout </LI></OL>
<P>When an array of structures are declared as a member of a struct, in the same manner as the Course structure, the data is inlined after the first two ints.&nbsp; We can get this data to Marshall properly by inserting a structure with the same size as the array of Students.&nbsp; The Native Student Structure is 52 bytes so we need a 260 byte structure.&nbsp; The following will do.&nbsp; </P>
<P mce_keep="true">&nbsp;</P><PRE>[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Size = 260 )]
    public struct ArrayBlob
    {
    }

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct Course
    {
        public int Id;
        public int Count;
        public ArrayBlob Blob;

        /* ... Methods ... */
    }
</PRE>
<P>This structure meets all of our requirments.&nbsp; Course is now properly formatted and can be Marshalled back and forth successfully.&nbsp; However our student array is stuck in a chunk of data that has no access methods.&nbsp; This blob is just an array of students in memory.&nbsp; Getting the Students out in C would be a snap.&nbsp; We could just grab the address, cast it the the appropriate pointer and run away with the Student elements.&nbsp; </P><PRE>Student *elements = (Student*)(&amp;(myCourse.Blob); </PRE>
<P>Unfortunately I'm giving these examples in Safe code so this is not allowed. You can get the same effect with C# although it's a bit slower and forces a memory allocation. We implement this as in indexer into the Course struct.</P><PRE>public Student this[int index]
        {
            get
            {
                if ( index &gt;= Count )
                {
                    throw new ArgumentOutOfRangeException();
                }

                IntPtr ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ArrayBlob)));
                try
                {
                    Marshal.StructureToPtr(this.Blob, ptr, false);
                    int offset = index * Marshal.SizeOf(typeof(Student));
                    IntPtr structPtr = new IntPtr(ptr.ToInt32() + offset);
                    return (Student)Marshal.PtrToStructure(structPtr, typeof(Student));
                }
                finally
                {
                    Marshal.FreeHGlobal(ptr);
                }
            }
        }</PRE>
<P>Some error checking was removed for brevity sake.&nbsp; Granted this is still a suboptimal way of accessing the members of the structure.&nbsp; Every index requires an allocation.&nbsp; But if you only interop for brief times and in non perf sensitive areas this code will do just fine.&nbsp; Here's an example.&nbsp; </P>
<P mce_keep="true">&nbsp;</P><PRE>public static class Enrollment
    {
        [DllImport("Enrollment.dll", CharSet = CharSet.Unicode)]
        public static extern IntPtr CreateStudent(
            [MarshalAs(UnmanagedType.LPWStr)] String firstName,
            [MarshalAs(UnmanagedType.LPWStr)] String lastName,
            int bDay,
            int bMon,
            int bYear);

        [DllImport("Enrollment.dll", CharSet = CharSet.Unicode)]
        public static extern void UpdateStudentInfo(
            [MarshalAs(UnmanagedType.LPWStr)] String firstName,
            [MarshalAs(UnmanagedType.LPWStr)] String lastName,
            int bDay,
            int bMon,
            int bYear,
            ref Student student);

        [DllImport("Enrollment.dll", CharSet = CharSet.Unicode)]
        public static extern IntPtr GetCourseInfo(int id);
    }


    class MarshalFun
    {
        static void Main(string[] args)
        {
            IntPtr ptr = Enrollment.GetCourseInfo(42);
            Course course = (Course)Marshal.PtrToStructure(ptr, typeof(Course));

            Student first = course[0];
            Student second = course[1];
        }
    }
</PRE>
<P>This code assumes that at least 2 students were returned from GetCourseInfo().&nbsp; This code is much cleaner than the previous example.&nbsp;&nbsp;It will also work with very large sized arrays.&nbsp; However it does have undue perf and memory overhead.&nbsp; Next time we'll look at a way to have the clean code and remove all of the perf problems present in the current code.&nbsp; </P>
<P><FONT size=2>This posting is provided "AS IS" with no warranties, and confers no rights. <BR>Use of included script samples are subject to the terms specified at </FONT><A title=http href="http://www.microsoft.com/info/cpyright.htm" mce_href="http://www.microsoft.com/info/cpyright.htm"><FONT face=Verdana color=#223355 size=2><STRONG>http://www.microsoft.com/info/cpyright.htm</STRONG></FONT></A><FONT face=Verdana size=2>.</FONT></P><div style="clear:both;"></div></div>
    