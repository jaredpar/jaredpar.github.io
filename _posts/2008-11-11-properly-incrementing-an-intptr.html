<p>Just as native pointer types are moved around with pointer arithmetic in native code, it can also be useful to move IntPtr types around in managed code.&#160; Say for instance there is an IntPtr available which points to a native array of Dog instances.&#160; To access the values of that array individually requires pointer arithmetic of a fashion.</p>  <p>For the most part this is a straight forward operation if the underlying native memory is understood.&#160; Say there is an array of Dog instances with length 10 and the Dog structure has a size of 8.&#160; The total amount of memory will be 80 bytes and with a valid dog instance being available at every 8 bytes.&#160; So if the start address is 1000 then 1000,1008,1016 and so on will point to a valid instance.</p>  <p>The native size of any data structure can be calculated via Marshal.SizeOf(tyepof(Dog)) [1].&#160; With a pointer to the start of the array, the Nth Dog instance can be accessed with a pointer of address = (N*sizeof(Dog))+startAddress</p>  <p>The address of a pointer can be accessed by 1 of 2 functions</p>  <ol>   <li>.ToIn32() </li>    <li>.ToInt64() </li> </ol>  <p>Unless you are writing an application that will every only run on a 32 bit system, <strong>don’t use method #1</strong> (even then still don’t).&#160; Native pointer addresses vary in size depending on version of the OS a program is running on.&#160; 64 bit systems have a much larger address size (long vs int).&#160; Consequently calling .ToInt32 on a 64bit system will truncate the actual address to a valid that is no longer valid.&#160; This will eventually lead to a random error PInvoke’ing a function that is difficult to track down.</p>  <p>Instead use .ToInt64().&#160; This method is safe on both 32 and 64 bit systems.&#160; Additionally constructing an IntPtr instance with either value is safe.&#160; The class knows what version of windows it’s executing on and will adjust the size in a safe way [2].&#160; </p>  <p>In many of my projects I define a class similar to the following to take care of this automatically.&#160; </p>  <pre class="code"><span style="color: blue">public static class </span><span style="color: #2b91af">IntPtrExtensions
</span>{
    <span style="color: blue">public static </span><span style="color: #2b91af">IntPtr </span>Increment(<span style="color: blue">this </span><span style="color: #2b91af">IntPtr </span>ptr, <span style="color: blue">int </span>cbSize)
    {
        <span style="color: blue">return new </span><span style="color: #2b91af">IntPtr</span>(ptr.ToInt64() + cbSize);
    }

    <span style="color: blue">public static </span><span style="color: #2b91af">IntPtr </span>Increment&lt;T&gt;(<span style="color: blue">this </span><span style="color: #2b91af">IntPtr </span>ptr)
    {
        <span style="color: blue">return </span>ptr.Increment(<span style="color: #2b91af">Marshal</span>.SizeOf(<span style="color: blue">typeof</span>(T)));
    }

    <span style="color: blue">public static </span>T ElementAt&lt;T&gt;(<span style="color: blue">this </span><span style="color: #2b91af">IntPtr </span>ptr, <span style="color: blue">int </span>index)
    {
        <span style="color: blue">var </span>offset = <span style="color: #2b91af">Marshal</span>.SizeOf(<span style="color: blue">typeof</span>(T))*index;
        <span style="color: blue">var </span>offsetPtr = ptr.Increment(offset);
        <span style="color: blue">return </span>(T)<span style="color: #2b91af">Marshal</span>.PtrToStructure(offsetPtr, <span style="color: blue">typeof</span>(T));
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>[1] It’s highly advisable to not calculate this value yourself.&#160; </p>

<p>[2] See the post “<a href="http://blogs.msdn.com/jaredpar/archive/2008/10/28/is-intptr-long-truncating.aspx">Is IntPtr(long) truncating?</a>” for more details</p></div>
    