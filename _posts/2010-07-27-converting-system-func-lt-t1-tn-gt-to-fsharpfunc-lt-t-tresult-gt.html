<p>Interop of delegate style types between F# and other .Net languages is a pain point that results from a fundamental difference in how delegates are represented in the F# language.&#160; Typical .Net languages like C# see a delegate as taking 0 to N parameters and potentially returning a value.&#160; F# represents all exposed delegates as taking and returning a single value via the <a href="http://msdn.microsoft.com/en-us/library/ee340302.aspx">FSharpFunc&lt;T,TResult&gt;</a> type.&#160; Multiple parameters are expressed by having the TResult type be yet another <a href="http://msdn.microsoft.com/en-us/library/ee340302.aspx">FSharpFunc&lt;T,TResult&gt;</a>.</p>  <p>This creates a host of problems calling exposed F# delegate / function types </p>  <ul>   <li>Can’t use C# lambda expressions which take more than one parameter </li>    <li>System.Func&lt;&gt; expressions of equivalent logical shape can’t be converted </li>    <li>Method group conversions don’t work </li> </ul>  <p>The only step is to introduce a conversion step when calling into F# code.&#160; F# does provide a helper method in F# in the <a href="http://msdn.microsoft.com/en-us/library/ee353520.aspx">FSharpFunc.FromConverter</a> method.&#160; But once again it’s only useful for delegates of one parameter, anything higher requires a more in depth conversion.&#160; For example here is the C# code to convert a 2 parameter delegate into the equivalent F# type.&#160; </p>  <pre class="code"><span style="color: blue">public static </span>FSharpFunc&lt;T1, FSharpFunc&lt;T2,TResult&gt;&gt; Create&lt;T1, T2, TResult&gt;(<span style="color: #2b91af">Func</span>&lt;T1,T2,TResult&gt; func)
{
    <span style="color: #2b91af">Converter</span>&lt;T1, FSharpFunc&lt;T2, TResult&gt;&gt; conv = value1 =&gt;
        {
            <span style="color: blue">return </span>Create&lt;T2,TResult&gt;(value2 =&gt; func(value1, value2));
        };
    <span style="color: blue">return </span>FSharpFunc&lt;T1, FSharpFunc&lt;T2, TResult&gt;&gt;.FromConverter(conv);
}</pre>


<p>Not very pretty or intuitive because the code needs to recreate the nested style of F# func’s.&#160; This gets even more tedious and error prone as it gets past 2 parameters.</p>

<p>The simplest solution, as is true with most F# interop scenarios, is to leverage F# itself to define the interop / conversion layer.&#160; It already naturally creates the proper nesting structure so why spend type redoing the logic in C#.&#160; The logic can then be exposed as a set of factory and extension methods to make it easily usable from C#.&#160; </p>

<pre class="code">[&lt;Extension&gt;]
<span style="color: blue">type public </span>FSharpFuncUtil = 

    [&lt;Extension&gt;] 
    <span style="color: blue">static member </span>ToFSharpFunc&lt;'a,'b&gt; (func:System.Converter&lt;'a,'b&gt;) = <span style="color: blue">fun </span>x <span style="color: blue">-&gt; </span>func.Invoke(x)

    [&lt;Extension&gt;] 
    <span style="color: blue">static member </span>ToFSharpFunc&lt;'a,'b&gt; (func:System.Func&lt;'a,'b&gt;) = <span style="color: blue">fun </span>x <span style="color: blue">-&gt; </span>func.Invoke(x)

    [&lt;Extension&gt;] 
    <span style="color: blue">static member </span>ToFSharpFunc&lt;'a,'b,'c&gt; (func:System.Func&lt;'a,'b,'c&gt;) = <span style="color: blue">fun </span>x y <span style="color: blue">-&gt; </span>func.Invoke(x,y)

    [&lt;Extension&gt;] 
    <span style="color: blue">static member </span>ToFSharpFunc&lt;'a,'b,'c,'d&gt; (func:System.Func&lt;'a,'b,'c,'d&gt;) = <span style="color: blue">fun </span>x y z <span style="color: blue">-&gt; </span>func.Invoke(x,y,z)

    <span style="color: blue">static member </span>Create&lt;'a,'b&gt; (func:System.Func&lt;'a,'b&gt;) = FSharpFuncUtil.ToFSharpFunc func

    <span style="color: blue">static member </span>Create&lt;'a,'b,'c&gt; (func:System.Func&lt;'a,'b,'c&gt;) = FSharpFuncUtil.ToFSharpFunc func

    <span style="color: blue">static member </span>Create&lt;'a,'b,'c,'d&gt; (func:System.Func&lt;'a,'b,'c,'d&gt;) = FSharpFuncUtil.ToFSharpFunc func</pre>


<p>Now I&#160; can convert instances of System.Func&lt;&gt; to the F# equivalent by simply calling .ToFSharpFunc().</p>

<pre class="code"><span style="color: blue">var </span>cmd = <span style="color: #2b91af">Command</span>.NewSimpleCommand(
    name,
    flagsRaw,
    func.ToFSharpFunc());</pre>
Much better.&#160; <div style="clear:both;"></div></div>
    