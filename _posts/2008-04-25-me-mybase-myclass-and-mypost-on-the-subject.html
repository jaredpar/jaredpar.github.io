<p>Recently we had a good discussion on an internal alias about the use of Me, MyClass and MyBase in VB.&nbsp; Me, MyBase and MyClass are all ways to access instance member data in a VB class or structure.&nbsp; There was a little bit of confusion on the actual workings and meanings of the keywords in various contexts and I want to use this post to shed light on the different meanings. </p> <h3>The Basics</h3> <p>The keywords are used to alter the way in which instance members of a class/structure are accessed.&nbsp; In particular they affect the way Overridable/MustOverride/Overrides functions are evaluated. Methods defined with Overridable/Overrides/MustOverride are defined as virtual by the CLR.&nbsp; For the purpose of this post all of these definitions are mostly equal.&nbsp; This discussion will be useless without and example so here's the code to discuss.</p><pre class="code"><span style="color: blue">Class </span>GrandParent
    <span style="color: blue">Public Overridable Sub </span>Sub1()
        Console.WriteLine(<span style="color: #a31515">"GrandParent.Sub1"</span>)
    <span style="color: blue">End Sub
End Class

Class </span>Parent
    <span style="color: blue">Inherits </span>GrandParent
    <span style="color: blue">Public Overrides Sub </span>Sub1()
        Console.WriteLine(<span style="color: #a31515">"Parent.Sub1"</span>)
    <span style="color: blue">End Sub
End Class

Class </span>Child
    <span style="color: blue">Inherits </span>Parent
    <span style="color: blue">Public Overrides Sub </span>Sub1()
        Console.WriteLine(<span style="color: #a31515">"Child.Sub1"</span>)
    <span style="color: blue">End Sub
End Class</span></pre>
<p>In this case Sub1 is a virtual method and there are three instances of it (one per class).&nbsp; By default virtual methods are called based on the runtime type of the object.&nbsp; The CLR will essentially walk the hierarchy from current type to object looking for the first class which defines a particular method and call that version.&nbsp; It doesn't matter what the variable type is declared as, just what type it actually is.</p><pre class="code"><span style="color: blue">Dim </span>v1 <span style="color: blue">As </span>GrandParent = <span style="color: blue">New </span>Parent
v1.Sub1()   <span style="color: green">' Calls Parent.Sub1
</span><span style="color: blue">Dim </span>v2 <span style="color: blue">As </span>GrandParent = <span style="color: blue">New </span>GrandParent
v2.Sub1()   <span style="color: green">' Calls GrandParent.Sub1</span></pre><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a>
<h3>Changing the call</h3>
<p>If the CLR will always call a virtual Sub/Function based on the runtime type of an object how can I access the parent function?&nbsp; This is where MyBase comes in.&nbsp; MyBase allows you to call the version of the virtual method defined in the parent class.&nbsp; Essentially it tells the CLR call this method/property as if my runtime type was my base type.&nbsp; </p><pre class="code"><span style="color: blue">Class </span>Child2
    <span style="color: blue">Inherits </span>Parent
    <span style="color: blue">Public Overrides Sub </span>Sub1()
        <span style="color: blue">MyBase</span>.Sub1()   <span style="color: green">' Calls Parent.Sub1
        </span>Console.WriteLine(<span style="color: #a31515">"Child2.Sub1"</span>)
    <span style="color: blue">End Sub
End Class
</span></pre><a href="http://11011.net/software/vspaste"></a>
<p>MyClass is similar to MyBase.&nbsp; Instead of telling the CLR the current type is the base type, it tells the CLR the runtime type is the type where MyClass is used.&nbsp; This allows developers to call their type's version of a virtual method no matter who derives from them.&nbsp; In the following example it doesn't matter how many, or who derives from Child3, Sub2 will always call the version of Sub1 defined in Child3.</p><pre class="code"><span style="color: blue">Class </span>Child3
    <span style="color: blue">Inherits </span>Parent
    <span style="color: blue">Public Overrides Sub </span>Sub1()
        Console.WriteLine(<span style="color: #a31515">"Child3.Sub1"</span>)
    <span style="color: blue">End Sub
    Public Sub </span>Sub2()
        <span style="color: blue">MyClass</span>.Sub1()
    <span style="color: blue">End Sub
End Class</span></pre>
<h3>So, why not MyChild?</h3>
<p>The short answer is, it's not verifiable.&nbsp; When writing MyBase we can verify that indeed there is a sub/function/property matching the call site in the base class.&nbsp; If no such method exists it will result in an error.&nbsp; MyClass is similarly easy to verify.&nbsp; With MyChild however there would be no useful way of guaranteeing a particular sub/function/property was defined on the child class.&nbsp; </p>
<p>One way you can verify a child class contains a particular property/sub/function is to make it MustOverride.&nbsp; However in this case there is no actual definition in the original type.&nbsp; In fact, if you try and access a MustOverride method with MyClass it will generate a compile time error. Therefore every call must at least occur in the child class or lower rendering MyChild superfluous.</p>
<h3>What about non-virtual methods and properties?</h3>
<p>The primary intent of MyBase/MyClass is to call virtual methods in a non-virtual way.&nbsp; However they can also be used to call non-virtual methods.&nbsp; From the perspective of the user calling a non-virtual method with MyBase/MyClass/Me has no discernable difference.&nbsp; If you crack open the generated IL you can see a small difference in the op code but the short story is it won't affect your program.&nbsp; </p></div>
    