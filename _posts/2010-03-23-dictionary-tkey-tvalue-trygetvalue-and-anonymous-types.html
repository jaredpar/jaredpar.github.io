<p>One of the methods I find to be the most useful in .Net is the method <a href="http://msdn.microsoft.com/en-us/library/bb347013.aspx">Dictionary&lt;TKey,TValue&gt;.TryGetValue</a>.&#160; This method is a nice compromise between performance, explicit return vs. exception, and a being verbal about the chance of failure.&#160; It returns false on failure and uses an out parameter to return the actual requested value.&#160; This leads to the following elegant pattern</p>  <pre class="code"><span style="color: #2b91af">Student </span>value;
<span style="color: blue">if </span>(map.TryGetValue(<span style="color: #a31515">&quot;SomeKey&quot;</span>, <span style="color: blue">out </span>value)) {
    <span style="color: green">// Value is present
</span>}
<span style="color: blue">else </span>{
    <span style="color: green">// Value is not present
</span>}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>This works great right up until have a Dictionary of anonymous types.&#160; The TryGetValue pattern functions on out parameters which do not work well with type inference in C# and hence anonymous types.&#160; Type inference requires that the value be declared with a corresponding initialization expression.&#160; But any out call forces the declaration of the type and the initialization expression to be different statements breaking any chance of type inference.</p>

<p>For example take the following code which builds up a Dictionary object where the value is typed to be an anonymous type [1]</p>

<pre class="code"><span style="color: blue">var </span>query = <span style="color: blue">from </span>it <span style="color: blue">in </span>GetStudents()
            <span style="color: blue">where </span>it.LastName.StartsWith(lastNamePrefix)
            <span style="color: blue">select new </span>{ FirsName = it.FirstName, LastName = it.LastName };
<span style="color: green">// ...
</span><span style="color: blue">var </span>map = query.ToDictionary(x =&gt; x.FirsName);

<span style="color: green">// How to use TryGetValue?  
</span>WhatDoIPutHere??? value;
<span style="color: blue">if </span>( map.TryGetValue(<span style="color: #a31515">&quot;Joe&quot;</span>, <span style="color: blue">out </span>value) {
    <span style="color: green">// ...
</span>}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>To fix this problem we need to write a wrapper around TryGetValue which allows us to combine both the presence or absence of the entry in the Dictionary and the resulting looked up value if present.&#160;&#160; Within our wrapper method we can use type inference tricks to avoid naming the anonymous type directly.&#160; To combine the values could construct a new type say TryGetValueResult&lt;TValue&gt;</p>

<pre class="code"><span style="color: blue">struct </span><span style="color: #2b91af">TryGetValueResult</span>&lt;TValue&gt; {
    <span style="color: blue">public readonly bool </span>Success;
    <span style="color: blue">public readonly </span>TValue Value;
    <span style="color: blue">public </span>TryGetValueResult(<span style="color: blue">bool </span>success, TValue value) {
        Success = success;
        Value = value;
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>But I find this to be a bit heavy handed for a simple return.&#160; Instead I prefer to combine the data with the new <a href="http://msdn.microsoft.com/en-us/library/dd268536(VS.100).aspx">Tuple&lt;T1,T2&gt;</a> type introduced in 4.0.&#160;&#160; This type is designed to be a light weight method for combining two related values into a single instance.&#160; Perfect for this type of method.&#160; </p>

<pre class="code"><span style="color: blue">public static </span><span style="color: #2b91af">Tuple</span>&lt;<span style="color: blue">bool</span>, TValue&gt; TryGetValue&lt;TKey, TValue&gt;(
    <span style="color: blue">this </span><span style="color: #2b91af">Dictionary</span>&lt;TKey, TValue&gt; map, 
    TKey key) {

    TValue value;
    <span style="color: blue">var </span>ret = map.TryGetValue(key, <span style="color: blue">out </span>value);
    <span style="color: blue">return </span><span style="color: #2b91af">Tuple</span>.Create(ret, value);
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>Now that we’ve built our wrapper method we can go back to the original code sample and use it to access the anonymous type values</p>

<pre class="code"><span style="color: blue">var </span>tuple = map.TryGetValue(<span style="color: #a31515">&quot;Joe&quot;</span>);
<span style="color: blue">if </span>(tuple.Item1) {
    <span style="color: #2b91af">Console</span>.WriteLine(tuple.Item2);
}</pre>

<p>This pattern is not limited strictly to TryGetValue.&#160; It’s fairly applicable anytime you need to combine a return value and one or more out parameters into a single value for reasons of type inference.&#160; </p>

<p>&#160;</p>

<p>[1] Believe it or not, having a Dictionary where the value type is an anonymous type is not a wholly uncommon act.&#160; I’ve run into a bit of customer code which follows this general pattern</p></div>
    