<p>Is it better to be wrong once or to be right then think you’re wrong but find out you were right but wrong about being wrong? Besides the obvious be right the first time, it’s certainly an educational experience.&#160; </p>  <p>Here’s the original sample:</p>  <pre class="code"><span style="color: blue">let </span>FoldRight combine (sequence:seq&lt;'a&gt;) acc = 
    <span style="color: blue">use </span>e = sequence.GetEnumerator()
    <span style="color: blue">let rec </span>inner cont = 
        <span style="color: blue">match </span>e.MoveNext() <span style="color: blue">with
            </span>| <span style="color: blue">true -&gt; 
                let </span>cur = e.Current
                inner (<span style="color: blue">fun </span>racc <span style="color: blue">-&gt; </span>cont (combine cur racc))
            | <span style="color: blue">false -&gt; </span>cont acc
    inner (<span style="color: blue">fun </span>x <span style="color: blue">-&gt; </span>x )</pre>
<a href="http://11011.net/software/vspaste"></a>

<p><a href="http://lorgonblog.spaces.live.com/blog/">Brian McNamara</a> pointed out I wasn’t considering all of the call sites for this sample.&#160; In addition to the recursive call to “inner” and the initial inner call, there is the actual recursive invocation of the of the continuations.&#160; Effectively the “inner” function is building up a list of list of lambdas which call the combine function.&#160; The output of the combine function is simply passed into the next lambda in the list.&#160; The last lambda in the list is the identity lambda and returns the final call to combine.&#160; This value is the actual value returned from the initial invocation “cont acc”.&#160; Lambdas are methods under the hood.&#160; Without a tail instruction, this chain of lambda calls will just as easily overflow the stack.</p>

<p>Digging deeper into the compiled F# code we can view this call and indeed it is done with tail recursion.&#160; </p>

<pre class="code"> 
.method public virtual instance !V Invoke(!U racc) cil managed
{
    .maxstack 8
    L_0000: nop 
    L_0001: ldarg.0 
    L_0002: ldfld class [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!0, !1> Program/clo@9<!U, !V, !A>::cont
    L_0007: ldarg.0 
    L_0008: ldfld class [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!2, class [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!0, !0>&gt; Program/clo@9<!U, !V, !A>::combine
    L_000d: ldarg.0 
    L_000e: ldfld !2 Program/clo@9<!U, !V, !A>::cur
    L_0013: ldarg.1 
    L_0014: call !!0 [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!A, !U>::InvokeFast2<!U>(class [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!0, class [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!1, !!0>&gt;, !0, !1)
    L_0019: tail 
    L_001b: callvirt instance !1 [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!U, !V>::Invoke(!0)
    L_0020: ret 
}</pre>

<p>The below code more accurately resembles the equivalent C# code that is generated for the above F# sample&#160; (thanks Brian!).&#160; </p>

<pre class="code"><span style="color: blue">public static </span>TAcc Inner&lt;TSource, TAcc&gt;(
    <span style="color: blue">this </span><span style="color: #2b91af">IEnumerator</span>&lt;TSource&gt; e,
    <span style="color: #2b91af">Func</span>&lt;TAcc, TSource, TAcc&gt; combine,
    TAcc start,
    <span style="color: #2b91af">Func</span>&lt;TAcc, TAcc&gt; cont)
{
    <span style="color: blue">while </span>(e.MoveNext())
    {
        <span style="color: blue">var </span>cur = e.Current;
        <span style="color: #2b91af">Func</span>&lt;TAcc, TAcc&gt; innerCont = cont;
        cont = (x) =&gt; <span style="color: green">/*need .tail here */</span>innerCont(combine(x, cur));
    }
    <span style="color: blue">return </span>cont(start);
}

<span style="color: blue">public static </span>TAcc FoldRight&lt;TSource, TAcc&gt;(
    <span style="color: blue">this </span><span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; enumerable,
    <span style="color: #2b91af">Func</span>&lt;TAcc, TSource, TAcc&gt; combine,
    TAcc start)
{
    <span style="color: blue">using </span>(<span style="color: blue">var </span>e = enumerable.GetEnumerator())
    {
        <span style="color: blue">return </span>Inner(e, combine, start, (x) =&gt; x);
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a>

<p><strong>Previous Entries</strong></p>

<ul>
  <li><a href="http://blogs.msdn.com/jaredpar/archive/2008/11/10/comparing-continuations-in-f-and-c.aspx">Part 1</a> </li>

  <li><a href="http://blogs.msdn.com/jaredpar/archive/2008/11/11/comparing-continuations-in-c-and-f-part-2.aspx">Part 2</a> </li>
</ul></div>
    