<P>When developing my <A href="http://code.msdn.microsoft.com/RantPack" mce_href="http://code.msdn.microsoft.com/RantPack">immutable collections library</A>, I spent a lot of time on usability.&nbsp; After all, if a library is not useful then what’s the point?</P>
<P>A big portion of usability is being able to work with existing frameworks and technologies.&nbsp; For .Net and collections that means items like Data binding, LINQ etc …&nbsp; Without integrating into popular technologies the usefulness of a particular library is severely impacted and hence usability decreases.</P>
<P>Most of the existing collection based infrastructures use the .Net collection interfaces as their form of abstraction.&nbsp; The most straight forward way to ensure compatibility is to implement these interfaces on the collections in question.&nbsp; In particular <A href="http://msdn.microsoft.com/en-us/library/92t2ye13.aspx" mce_href="http://msdn.microsoft.com/en-us/library/92t2ye13.aspx">ICollection&lt;T&gt;</A>, <A href="http://msdn.microsoft.com/en-us/library/5y536ey6.aspx" mce_href="http://msdn.microsoft.com/en-us/library/5y536ey6.aspx">IList&lt;T&gt;</A> and <A href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx" mce_href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx">IEnumerable&lt;T&gt;</A> are the main abstractions.&nbsp; Lets investigate which ones an Immutable collection should be implementing in order to effectively integrate into existing collection based infrastructures.</P>
<P><STRONG>IEnumerable&lt;T&gt;</STRONG></P>
<P>This is the easiest decision.&nbsp; IEnumerable&lt;T&gt; represents a read only, one element at time view on a sequence of objects.&nbsp; Immutable collections can easily and reliably implement a IEnumerable&lt;T&gt;.&nbsp; This is a no brainer.&nbsp; Implement.</P>
<P><STRONG>ICollection&lt;T&gt;</STRONG></P>
<P>This interfaces represents a general collection class.&nbsp; Unfortunately this interface is meant to represent a mutable collection class and implements such methods as Add, Clear and Remove.&nbsp; These methods cannot be implemented on an Immutable collection given the current design.&nbsp; All three of these methods are void returning methods because the collection is meant to be changed in place.&nbsp; Immutable collections can support these operations but it involves returning a new instance of the collection.&nbsp; </P><PRE class=code><SPAN style="COLOR: blue">public sealed class </SPAN><SPAN style="COLOR: #2b91af">ImmutableCollection</SPAN>&lt;T&gt; : <SPAN style="COLOR: #2b91af">ICollection</SPAN>&lt;T&gt; {
    <SPAN style="COLOR: blue">public </SPAN><SPAN style="COLOR: #2b91af">ImmutableCollection</SPAN>&lt;T&gt; Add(T item) {
        <SPAN style="COLOR: green">// Actually add 
        // ...
    </SPAN>}

    <SPAN style="COLOR: blue">#region </SPAN>ICollection&lt;T&gt; Members

    <SPAN style="COLOR: blue">void </SPAN><SPAN style="COLOR: #2b91af">ICollection</SPAN>&lt;T&gt;.Add(T item) {
        <SPAN style="COLOR: blue">var </SPAN>created = <SPAN style="COLOR: blue">this</SPAN>.Add(item);
        <SPAN style="COLOR: green">// What to do with created???
    </SPAN>}

    ...
}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>But wait!&nbsp; The interface does support a property named <A href="http://msdn.microsoft.com/en-us/library/0cfatk9t.aspx" mce_href="http://msdn.microsoft.com/en-us/library/0cfatk9t.aspx">IsReadOnly</A>.&nbsp; The intention of this property is to allow an interface to programmatically declare they do not support modifications.&nbsp; A read only collection can just implement this interface, throw a&nbsp;<A class="" title=NotSupportedException href="http://msdn.microsoft.com/en-us/library/system.notsupportedexception.aspx" mce_href="http://msdn.microsoft.com/en-us/library/system.notsupportedexception.aspx">NotSupportedException</A> for all of the mutable methods and return true for IsReadOnly and presto we have a suitable interface for an immutable collection.&nbsp; </P>
<P>Or do we?&nbsp; </P>
<P>The design for ICollection&lt;T&gt; with respect to read only or immutable collections is not optimal.&nbsp; It attempts to combine to separate behaviors into a single interface: mutable and readonly view of a collection.&nbsp; Dual purpose interfaces run into problems because it’s impossible to separate out the behaviors at compile time.&nbsp; This is especially problematic when the behaviors are conflicting.&nbsp; There is no way a read only collection can prevent itself from being passed to a function that expects a mutable collection at compile time.&nbsp; Nor can a consumer who intends to mutate a collection prevent a read-only collection from being passed. </P><PRE class=code><SPAN style="COLOR: blue">static void </SPAN>DisplayForEdit&lt;T&gt;(<SPAN style="COLOR: #2b91af">ICollection</SPAN>&lt;T&gt; col) {
    <SPAN style="COLOR: green">// ...
    </SPAN>m_clearButton.Click += (x, y) =&gt; col.Clear(); 
}

<SPAN style="COLOR: blue">static void </SPAN>Example1() {
    <SPAN style="COLOR: #2b91af">ImmutableCollection</SPAN>&lt;<SPAN style="COLOR: blue">int</SPAN>&gt; col = <SPAN style="COLOR: #2b91af">ImmutableCollection</SPAN>.Create(<SPAN style="COLOR: blue">new int</SPAN>[] { 1, 2, 3, 4 });
    DisplayForEdit(col);    <SPAN style="COLOR: green">// Will fail as soon as Clear is clicked
</SPAN>}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>But isn’t it the responsibility of the user of ICollection&lt;T&gt; to verify that IsReadOnly is false before mutating a instance?&nbsp; Given the current design of ICollection&lt;T&gt; it is indeed both the responsibility of the consumer to verify this and the implementer to ensure they are not called incorrectly.&nbsp; The problem with putting responsibility on the consumer though is they have to 1) know about read only uses of ICollection&lt;T&gt; and 2) actually care about it.&nbsp; </P>
<P>A quick search of the BCL with reflector can give us evidence of how much consumers actually check for the read only scenario.&nbsp; For the search I used mscorlib, System, System.Xml, System.Data, System.Drawing and System.Core and System.Windows.Forms.&nbsp; And the number of classes which actually take into account ICollection&lt;T&gt;.IsReadOnly is … 1.&nbsp; System.Collections.ObjectModel.Collection&lt;T&gt;.&nbsp; That’s it.&nbsp; </P>
<P>So even if an immutable collection implements this interface in a read-only fashion there’s little chance anyone will be checking for it.&nbsp; </P>
<P><STRONG>IList&lt;T&gt;</STRONG></P>
<P>IList&lt;T&gt; inherits from ICollection&lt;T&gt; and hence suffers from all of the same problems</P>
<P><STRONG>Decision Time</STRONG></P>
<P>In order to facilitate usability with existing frameworks immutable collections are forced to implement interfaces for which they have no possible way of implementing properly.&nbsp; If collections implement these interfaces they will be trading usability for compile time validation.&nbsp; Even worse is the conversion is implicit which prevents even basic searches for places this conversion occurs.&nbsp; This is a heavy price to pay for compatibility. </P>
<P>After debating this for awhile I decided that loss of compile time validation was a too heavy of a price to pay for the default scenario.&nbsp; But trading away usability was also unacceptable.&nbsp; As a compromise I opted for adding a compatibility layer to the collections.&nbsp; Instead of implementing the ICollection&lt;T&gt; and IList&lt;T&gt; collections directly I created a set of proxy objects that implement the interfaces on behalf of the immutable collections.&nbsp; </P>
<P>In order to centralize this effort I created a factory class, CollectionUtility, which contains appropriate overloads for all of my immutable collection classes [1].&nbsp; </P><PRE class=code><SPAN style="COLOR: blue">public static class </SPAN><SPAN style="COLOR: #2b91af">CollectionUtility </SPAN>{
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IEnumerable</SPAN>&lt;T&gt; CreateEmptyEnumerable&lt;T&gt;();
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IEnumerable</SPAN>&lt;T&gt; CreateEnumerable&lt;T&gt;(T value);
<SPAN style="COLOR: green">    </SPAN><SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">ICollection</SPAN>&lt;T&gt; CreateICollection&lt;T&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyCollection</SPAN>&lt;T&gt; col);
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IDictionary</SPAN>&lt;TKey, TValue&gt; CreateIDictionary&lt;TKey, TValue&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyMap</SPAN>&lt;TKey, TValue&gt; map);
<SPAN style="COLOR: green">    </SPAN><SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IList</SPAN>&lt;T&gt; CreateIList&lt;T&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyList</SPAN>&lt;T&gt; list);
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">ICollection </SPAN>CreateObjectICollection&lt;T&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyCollection</SPAN>&lt;T&gt; col);
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IDictionary </SPAN>CreateObjectIDictionary&lt;TKey, TValue&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyMap</SPAN>&lt;TKey, TValue&gt; map);
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IList </SPAN>CreateObjectIList&lt;T&gt;(<SPAN style="COLOR: #2b91af">IReadOnlyList</SPAN>&lt;T&gt; list);
    <SPAN style="COLOR: blue">public static </SPAN><SPAN style="COLOR: #2b91af">IEnumerable</SPAN>&lt;<SPAN style="COLOR: blue">int</SPAN>&gt; GetRangeCount(<SPAN style="COLOR: blue">int </SPAN>start, <SPAN style="COLOR: blue">int </SPAN>count);
}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>The proxy objects live as private inner classes inside CollectionUtility.&nbsp; They implement the collection interfaces in the most read-only way possible.&nbsp; When confronted with mutating calls, the proxies throw <A class="" title=NotSupportedException href="http://msdn.microsoft.com/en-us/library/system.notsupportedexception.aspx" mce_href="http://msdn.microsoft.com/en-us/library/system.notsupportedexception.aspx">NotSupportedException</A>.&nbsp; </P>
<P>So at the end of the day I have compile time validation for immutable collections.&nbsp; If a developer wants to use them in a less than safe scenario it requires an explicit conversion.&nbsp;&nbsp;&nbsp; </P><PRE class=code><SPAN style="COLOR: blue">static void </SPAN>Example2() { 
  <SPAN style="COLOR: blue">var </SPAN>col = <SPAN style="COLOR: #2b91af">ImmutableCollection</SPAN>.Create(<SPAN style="COLOR: blue">new int</SPAN>[] { 1, 2, 3, 4 }); 
  <SPAN style="COLOR: green">// Still fails, but explicit conversion required 
  </SPAN>DisplayForEdit(<SPAN style="COLOR: #2b91af">CollectionUtility</SPAN>.CreateICollection(col)); 
  }</PRE>
<P>I feel like this as an appropriate tradeoff.&nbsp;&nbsp; In the worst case scenario, a developer can search for all accesses of the CollectionUtility class and find places where a proxy is being created.</P>
<P>Next time, lets take a look at a different way of approaching an interface hierarchy for a set of collections.&nbsp; One that will allow us to avoid this problem altogether going forward.&nbsp; </P>
<P>[1] It actually contains overloads for a set of truly read only collection interfaces that I wrote for my library but we’ll get to that another time.&nbsp; </P>
<P>Edit: Updated the exception to be NotSupportedException</P></div>
    