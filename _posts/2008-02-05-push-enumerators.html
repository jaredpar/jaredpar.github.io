<p>If you read Jon Skeet's blog you'll notice he's been playing around lately with "push" style enumerators.&nbsp; Push enumerators are the concept of "we'll tell you when we're ready".&nbsp; This is different from IEnumerator&lt;T&gt; which is more of a pull; "ask me if I have more data model".</p> <p>His latest idea is an interface based approach called IDataProducer&lt;T&gt;.&nbsp; The full post can be found here.&nbsp; <a title="http://msmvps.com/blogs/jon.skeet/archive/2007/11/29/group-pipelining-returns-new-and-improved-design.aspx" href="http://msmvps.com/blogs/jon.skeet/archive/2007/11/29/group-pipelining-returns-new-and-improved-design.aspx">http://msmvps.com/blogs/jon.skeet/archive/2007/11/29/group-pipelining-returns-new-and-improved-design.aspx</a>.&nbsp; </p> <p>After reading the post I decided to try and bridge the gap between the worlds of Push/Pull models by defining an enumerator over an IDataProducer&lt;T&gt;.&nbsp; Integration with the existing paradigms is extremely important for the adoption of a new technology.&nbsp; Eventually you'll eventually want to pass your asynchronous enumerator off to an API requiring IEnumerable&lt;T&gt;.&nbsp; </p> <p>Since we are implementing a pull model it will revolve around asking for more data and blocking until such data is available.&nbsp; To implement the wait functionality I've used an AutoResetEvent to provide signaling between threads.&nbsp; One of the tricky aspects is that IDataProducer&lt;T&gt; can live on any thread and hence any thread can be raising the various events.&nbsp; </p> <p>Below is my first attempt at getting it to work.&nbsp; It has a couple of defects.</p> <ol> <li>I don't dispose of the AutoResetEvent.&nbsp; Reason being that it's possible for a consumer of IEnumerable&lt;T&gt; to only consume part of the data.&nbsp; If they only consume half of the data and then dispose of the EnumerableDataProducer and another event comes I'll be accessing a disposed WaitHandle.&nbsp; You can work around this but I wanted to keep it simpler for now.</li> <li>It's not Reset-able.&nbsp; The generated IEnumerator&lt;T&gt; throws a NotSupportedException anyway but we'd have to do a bit of work to make this resetable.&nbsp; </li></ol><pre class="code">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">EnumerableDataProducer</span>&lt;T&gt; : <span style="color: rgb(43,145,175)">IEnumerable</span>&lt;T&gt;
    {
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">object</span> m_lock = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(0,0,255)">object</span>();
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">bool</span> m_finished;
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">AutoResetEvent</span> m_event = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">AutoResetEvent</span>(<span style="color: rgb(0,0,255)">false</span>);
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">Queue</span>&lt;T&gt; m_queue = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Queue</span>&lt;T&gt;();

        <span style="color: rgb(0,0,255)">public</span> EnumerableDataProducer(<span style="color: rgb(43,145,175)">IDataProducer</span>&lt;T&gt; producer)
        {
            producer.DataProduced += <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Action</span>&lt;T&gt;(OnDataProdecuded);
            producer.EndOfData += <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Action</span>(OnEndOfData);
        }

        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">void</span> OnDataProdecuded(T obj)
        {
            <span style="color: rgb(0,0,255)">lock</span> (m_lock)
            {
                m_queue.Enqueue(obj);
            }

            m_event.Set();
        }

        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">void</span> OnEndOfData()
        {
            <span style="color: rgb(0,0,255)">lock</span> (m_lock)
            {
                m_finished = <span style="color: rgb(0,0,255)">true</span>;
            }
            m_event.Set();
        }

<span style="color: rgb(0,0,255)">        #region</span> IEnumerable&lt;T&gt; Members

        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(43,145,175)">IEnumerator</span>&lt;T&gt; GetEnumerator()
        {
            <span style="color: rgb(0,0,255)">while</span> (<span style="color: rgb(0,0,255)">true</span>)
            {
                <span style="color: rgb(0,0,255)">bool</span> needWait = <span style="color: rgb(0,0,255)">false</span>;
                <span style="color: rgb(0,0,255)">lock</span> (m_lock)
                {
                    <span style="color: rgb(0,0,255)">if</span> (m_finished)
                    {
                        <span style="color: rgb(0,0,255)">break</span>;
                    }

                    <span style="color: rgb(0,0,255)">if</span> (m_queue.Count &gt; 0)
                    {
                        <span style="color: rgb(0,0,255)">yield</span> <span style="color: rgb(0,0,255)">return</span> m_queue.Dequeue();
                    }
                    <span style="color: rgb(0,0,255)">else
</span>                    {
                        needWait = <span style="color: rgb(0,0,255)">true</span>;
                    }
                }

                <span style="color: rgb(0,0,255)">if</span> (needWait)
                {
                    m_event.WaitOne();
                }
            }
        }

<span style="color: rgb(0,0,255)">        #endregion

        #region</span> IEnumerable Members

        System.Collections.<span style="color: rgb(43,145,175)">IEnumerator</span> System.Collections.<span style="color: rgb(43,145,175)">IEnumerable</span>.GetEnumerator()
        {
            <span style="color: rgb(0,0,255)">return</span> GetEnumerator();
        }

<span style="color: rgb(0,0,255)">        #endregion
</span>    }
</pre><a href="http://11011.net/software/vspaste"></a></div>
    