<p>For previous articles in this series, please see</p> <ul> <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/04/27/closures-in-vb-part-1.aspx">Part 1 - The basics</a></li></ul> <p>This part of the series will focus on how method calls are handled in closures.&nbsp;&nbsp;As stated in the previous article, the purpose of closures is to allow all operations inside a lambda or query expression that would normally be available inside the function or sub.&nbsp; To do this closures often need to capture (or lift) relevant variables from the function into the generated class.</p> <p>There are&nbsp;2 types of methods and method calls that closures have to handle.&nbsp; </p> <ol> <li>Method calls to a shared method or methods on modules.  <li>Method calls to instance members of a class </li></ol> <p><strong>Scenario #1 </strong></p> <p>Below is an example of a method call inside a lambda expression for scenario #1.&nbsp; </p><pre><span style="color: blue">Module</span> M1

    <span style="color: blue">Function</span> MyValue() <span style="color: blue">As</span> <span style="color: blue">Integer</span>
        <span style="color: blue">Return</span> <span style="color: maroon">42</span>
    <span style="color: blue">End</span> <span style="color: blue">Function</span>

    <span style="color: blue">Sub</span> Example1()
        <span style="color: blue">Dim</span> x = <span style="color: maroon">5</span>
        <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() x + MyValue()
    <span style="color: blue">End</span> <span style="color: blue">Sub</span>

<span style="color: blue">End</span> <span style="color: blue">Module</span></pre>
<p>Here we are calling a&nbsp;module method inside a lambda.&nbsp; Module Methods or Shared methods can be called from anywhere because they require no specific variable for the call.&nbsp; This requires no special work from closures as the call can just be made naturally.</p><pre>    <span style="color: blue">Class</span> Closure
        <span style="color: blue">Private</span> x <span style="color: blue">As</span> <span style="color: blue">Integer</span>

        <span style="color: blue">Function</span> Lambda_f() <span style="color: blue">As</span> <span style="color: blue">Integer</span>
            <span style="color: blue">Return</span> x + M1.MyValue
        <span style="color: blue">End</span> <span style="color: blue">Function</span>
    <span style="color: blue">End</span> <span style="color: blue">Class</span>
</pre>
<p><strong>Scenario #2</strong></p>
<p>Calling an instance method is more difficult than a shared method because it requires the referenc "Me".&nbsp; If you don't type this specifically in code the VB Compiler will add it for you under the hood.&nbsp; To make this work the closures code will also "lift" the variable "Me" in the same way that it lifts normal variables in a function.&nbsp; </p>
<p>Calling a instance method inside a lambda expression is little difference than calling a member method on a variable used in a lambda.&nbsp; The only difference is the variable is "Me".&nbsp; For example</p><pre><span style="color: blue">Class</span> C1
    <span style="color: blue">Private</span> m_myValue <span style="color: blue">As</span> <span style="color: blue">Integer</span>

    <span style="color: blue">Function</span> MyValue() <span style="color: blue">As</span> <span style="color: blue">Integer</span>
        <span style="color: blue">Return</span> m_myValue
    <span style="color: blue">End</span> <span style="color: blue">Function</span>

    <span style="color: blue">Sub</span> Example2()
        <span style="color: blue">Dim</span> x = <span style="color: maroon">5</span>
        <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() x + MyValue()
    <span style="color: blue">End</span> <span style="color: blue">Sub</span>
<span style="color: blue">End</span> <span style="color: blue">Class</span></pre>
<p>In this case we need to access both "x" and "Me.MyValue()" from the closure.&nbsp; The generated code will create space for both of these variables and the transformed code in Example2 will store both of the values.</p><pre><span style="color: blue">Class</span> Closure
    <span style="color: blue">Private</span> x <span style="color: blue">As</span> <span style="color: blue">Integer</span>
    <span style="color: blue">Private</span> OriginalMe <span style="color: blue">As</span> C1

    <span style="color: blue">Function</span> Lambda_f()
        <span style="color: blue">Return</span> x + OriginalMe.MyValue()
    <span style="color: blue">End</span> <span style="color: blue">Function</span>
<span style="color: blue">End</span> <span style="color: blue">Class</span></pre><pre>    <span style="color: blue">Sub</span> Example2()
        <span style="color: blue">Dim</span> c <span style="color: blue">As</span> <span style="color: blue">New</span> Closure
        c.x = <span style="color: maroon">5</span>
        c.OriginalMe = <span style="color: blue">Me</span>
        <span style="color: blue">Dim</span> f = <span style="color: blue">New</span> Func(Of <span style="color: blue">Integer</span>)(<span style="color: blue">AddressOf</span> c.Lambda_f)
    <span style="color: blue">End</span> <span style="color: blue">Sub</span></pre>
<p>As usual, the generated code is much uglier but this essentially what will be generated.&nbsp; That wraps it up for method calls.&nbsp; In the next part, I will discuss the variable liftetime and scoping issues that come into play with closures.&nbsp; </p></div>
    