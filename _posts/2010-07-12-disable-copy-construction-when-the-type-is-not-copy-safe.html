<p>A couple of days ago I finished coding up a feature in our C++ code base, hit F5 and was met with a nasty memory corruption debugger dialog.&nbsp; After about an hour of investigation it appeared one of my types was living past the lifetime of it&rsquo;s owning heap. I decided the next step was to debug on the heap functions to see where I went wrong.&nbsp; I opened up the file for the heap and almost immediately new what I had done wrong.&nbsp; </p>
<p>Here&rsquo;s a trimmed down version of the heap type I was looking at.&nbsp; </p>
<pre class="code"><span style="color: blue">class </span>SpecialHeap {
<span style="color: blue">public</span>:
    SpecialHeap() { 
        m_pBlock = ::VirtualAlloc(...);
        <span style="color: green">// Memory management magic
    </span>}

    ~SpecialHeap() {
        VirtualFree(m_pBlock, ...);
    }

    <span style="color: blue">void</span>* Allocate(sizet_ bytes) { }
<span style="color: blue">private</span>:
    <span style="color: blue">void</span>* m_pBlock;
}</pre>
<p>Anyone else immediately guess what I did wrong[1]?&nbsp; </p>
<p>What&rsquo;s relevant is the code that&rsquo;s not on the screen.&nbsp; Namely the default copy constructor generated by the C++ compiler. Types in C++ which don&rsquo;t explicitly define a copy constructor are given a default copy constructor by the compiler.&nbsp; This is great for several classes of types in C++ as it allows for handy value copying with no extra user code.&nbsp; </p>
<p>One type it&rsquo;s terrible for though are those which manage resources that are not meant to be shared.&nbsp; Types like our SpecialHeap for example.&nbsp; Any instance of SpecialHeap which is created via a copy constructor is a time bomb.&nbsp; A copy means there is an original and hence 2 SpecialHeap instances running around which refer to the same m_pBlock value.&nbsp; After the first destructor runs the other instance is left holding a garbage pointer.&nbsp; </p>
<p>After taking one look at this I knew I almost certainly left a &amp; off of a SpecialHeap parameter which I intended to pass by reference. Instead it created a copy and when the function returned it destroyed the heap memory I expected to be alive.&nbsp; A quick scan of my change verified this was indeed the bug.&nbsp; </p>
<p>What&rsquo;s really frustrating is that this bug is 100% preventable.&nbsp; Types can opt out of copy construction by simply declaring a user defined copy constructor with no implementation.&nbsp; [2]</p>
<pre class="code"><span style="color: blue">private</span>:
    <span style="color: green">// Disable value copying
    </span>SpecialHeap(<span style="color: blue">const </span>SpecialHeap&amp;);
    SpecialHeap&amp; <span style="color: blue">operator</span>=(<span style="color: blue">const </span>SpecialHeap&amp;);</pre>
<p>This code just turned my runtime bug into a compilation error.&nbsp; What&rsquo;s very frustrating about this issue is that it took &lt; 1 minute to type and would have saved me an hour of debugging had the original author taken the time to add it.&nbsp; This type is not copy safe and allowing it to have a copy constructor is simply a bug.&nbsp; </p>
<p>This pattern is not special to this bug.&nbsp; It should be done for every single type you ever define in C++ that you do not explicitly intend to be copied.&nbsp; Getting in the habit of adding the above code <strong>will </strong>save you and others hours of debugging at some point down the road.&nbsp; </p>
<p>[1] The title of the blog post is a big give away </p>
<p>[2] Making it private has the added bonus of being a binding error in almost all cases vs. a linker error </p><div style="clear:both;"></div></div>
    