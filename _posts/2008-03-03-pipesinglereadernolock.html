<P>Previously we discussed a multi-thread safe <A href="http://blogs.msdn.com/jaredpar/archive/2008/03/02/pipesinglereader.aspx" mce_href="http://blogs.msdn.com/jaredpar/archive/2008/03/02/pipesinglereader.aspx">queue like data structure</A> using locks as an internal synchronization mechanism.&nbsp; This time we'll look at a version requiring no locks.&nbsp; </P>
<P>In the previous version, locks were used to synchronize access to an underlying queue which stored the data.&nbsp; Removing the locks necessitates us moving away from Queue&lt;T&gt; to store the data and forces us onto another structure which is safe in the presence of multiple threads.&nbsp; </P>
<P>Immutable collections are safe in the presence of multiple threads and don't require any synchronization mechanisms.&nbsp; However they're immutable and we're trying to build a mutable data structure?&nbsp; No matter.&nbsp; Even though each instance is immutable they can be used to create new instances which represent a somewhat mutated state.&nbsp; </P>
<P>For this exercise we will be using a slight variant of Eric Lippert's <A href="http://blogs.msdn.com/ericlippert/archive/2007/12/04/immutability-in-c-part-two-a-simple-immutable-stack.aspx" mce_href="http://blogs.msdn.com/ericlippert/archive/2007/12/04/immutability-in-c-part-two-a-simple-immutable-stack.aspx">Immutable Stack</A> implementation [1].&nbsp; The pipe will have two stacks; 1) for capturing input and 2) for storing output.&nbsp; Named m_writeStack and m_readStack respectively.</P>
<P>This makes the implementation of reading input straight forward.&nbsp; While m_readStack is not empty the reader thread can systematically pop off the values.&nbsp; This doesn't require any contention with writer threads and since their is only one reader thread and the stack is immutable the code is straight forward.&nbsp; Once the m_readStack is empty the reader thread will swap out the current state of m_writeStack with an empty stack.&nbsp; The original value will be reversed so we can maintain the FIFO ordering and set as the new m_readStack.&nbsp; </P><PRE class=code><SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> CheckForInput() {
    <SPAN style="COLOR: rgb(0,0,255)">if</SPAN>( m_readerStack.IsEmpty ) {
        <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> prev = <SPAN style="COLOR: rgb(43,145,175)">Interlocked</SPAN>.Exchange(<SPAN style="COLOR: rgb(0,0,255)">ref</SPAN> m_writerStack, <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt;.Empty);
        m_readerStack = prev.Reverse();
    }
    <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> !m_readerStack.IsEmpty;
}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>Writing data is more complicated because it must deal with contention for updating the same data structure.&nbsp; It can be altered by other writers or the reader thread when it runs out of data.&nbsp; Basically it must push a value onto the stack and update the m_writerStack to point to the new value.&nbsp; In between the operations the value of m_writerStack could change and thus invalidate the push.&nbsp; To guard against this the writer must guarantee the current value of the m_writerStack is the same as it was before the push operation.&nbsp; Interlocked.CompareExchange will do the trick.&nbsp; If it's been changed then repeat the operation.&nbsp; </P><PRE class=code><SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> AddInput(T value) {
    <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> done;
    <SPAN style="COLOR: rgb(0,0,255)">do</SPAN> {
        <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_inputClosed) {
            <SPAN style="COLOR: rgb(0,0,255)">throw</SPAN> <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">InvalidOperationException</SPAN>(<SPAN style="COLOR: rgb(163,21,21)">"Input end of pipe is closed"</SPAN>);
        }
        <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> originalStack = m_writerStack;
        <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> newStack = originalStack.Push(value);
        <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> currentStack = <SPAN style="COLOR: rgb(43,145,175)">Interlocked</SPAN>.CompareExchange(<SPAN style="COLOR: rgb(0,0,255)">ref</SPAN> m_writerStack, newStack, originalStack);
        done = <SPAN style="COLOR: rgb(0,0,255)">object</SPAN>.ReferenceEquals(currentStack, originalStack);
    } <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (!done);
    m_event.Set();
}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>At a glance it may seem like this suffers from the <A href="http://en.wikipedia.org/wiki/ABA_problem" mce_href="http://en.wikipedia.org/wiki/ABA_problem">ABA problem</A>.&nbsp; This is not the case and it's easy to prove.&nbsp; In between the read and push operation only two other operations can modify the m_writeStack variable.&nbsp; The first is another write which will produce a new value of ImmutableStack&lt;T&gt;.&nbsp; In this case the CLR guarantees that the references will not be equal and the CAS operation won't succeed.&nbsp; The second is the reader thread swaps out the value and replaces it with Empty.&nbsp; It's possible to hit an ABA situation here (detailed below) but fundamentally if it was empty before and empty now the operation is still safe.&nbsp; No data is lost&nbsp;because we are still replacing an empty stack with a single value'd stack.&nbsp;&nbsp;</P>
<P>Here's a more elaborate version starting with an empty pipe of type int</P>
<OL>
<LI>Thread 1: Begins to write 5 and is stopped just before the CAS operation</LI>
<OL>
<LI>originalStack points to ImmutableStack&lt;int&gt;.Empty</LI></OL>
<LI>Thread 2: Starts and completes a write of the value 6</LI>
<LI>Thread 3: Reads a value from the pipe, having no data replaces m_writeStack with ImmutableStack&lt;int&gt;.Empty</LI>
<LI>Thread 1: Resumes and the CAS succeeds even though the m_writeStack technically changed in the middle of the operation</LI></OL>
<P>Even though this exhibits many characterstics of the ABA pattern it is not a problem because the behavior is still correct.&nbsp; No data was lost because it was transferred to the reader thread.&nbsp;&nbsp;The end result is m_writeStack pointing to a single vaue'd stack containing the data 5 which is valid.&nbsp;&nbsp;The pipe does not guarantee the ordering of data between writer threads (merely the ordering between a single writer thread).&nbsp; </P>
<P>Below is the implementation in it's entirety.&nbsp; </P><PRE class=code><SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">class</SPAN> <SPAN style="COLOR: rgb(43,145,175)">PipeSingleReaderNoLock</SPAN>&lt;T&gt; : <SPAN style="COLOR: rgb(43,145,175)">IDisposable</SPAN> {
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ThreadAffinity</SPAN> m_affinity = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ThreadAffinity</SPAN>();
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt; m_readerStack = <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt;.Empty;
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt; m_writerStack = <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt;.Empty;
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(43,145,175)">AutoResetEvent</SPAN> m_event = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">AutoResetEvent</SPAN>(<SPAN style="COLOR: rgb(0,0,255)">false</SPAN>);
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">volatile</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> m_inputClosed;

    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> PipeSingleReaderNoLock() {
    }

<SPAN style="COLOR: rgb(0,0,255)">    #region</SPAN> Dispose
    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> Dispose() {
        Dispose(<SPAN style="COLOR: rgb(0,0,255)">true</SPAN>);
        <SPAN style="COLOR: rgb(43,145,175)">GC</SPAN>.SuppressFinalize(<SPAN style="COLOR: rgb(0,0,255)">this</SPAN>);
    }
    ~PipeSingleReaderNoLock() {
        Dispose(<SPAN style="COLOR: rgb(0,0,255)">false</SPAN>);
    }
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> Dispose(<SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> disposing) {
        <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (disposing) {
            m_event.Close();
        }
    }
<SPAN style="COLOR: rgb(0,0,255)">    #endregion
</SPAN>    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> WaitForOutput() {
        m_affinity.Check();
        <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (!CheckForInput()) {
            m_event.WaitOne();
        }
    }
    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> T GetNextOutput() {
        m_affinity.Check();
        T data;
        <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (!TryGetOutput(<SPAN style="COLOR: rgb(0,0,255)">out</SPAN> data)) {
            m_event.WaitOne();
        }
        <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> data;
    }
    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> TryGetOutput(<SPAN style="COLOR: rgb(0,0,255)">out</SPAN> T value) {
        m_affinity.Check();
        <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (CheckForInput()) {
            value = m_readerStack.Peek();
            m_readerStack = m_readerStack.Pop();
            <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(0,0,255)">true</SPAN>;
        }
        <SPAN style="COLOR: rgb(0,0,255)">else</SPAN> {
            value = <SPAN style="COLOR: rgb(0,0,255)">default</SPAN>(T);
            <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(0,0,255)">false</SPAN>;
        }
    }
    <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> CheckForInput() {
        <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_readerStack.IsEmpty) {
            <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> prev = <SPAN style="COLOR: rgb(43,145,175)">Interlocked</SPAN>.Exchange(<SPAN style="COLOR: rgb(0,0,255)">ref</SPAN> m_writerStack, <SPAN style="COLOR: rgb(43,145,175)">ImmutableStack</SPAN>&lt;T&gt;.Empty);
            m_readerStack = prev.Reverse();
        }
        <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> !m_readerStack.IsEmpty;
    }
    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> AddInput(T value) {
        <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> done;
        <SPAN style="COLOR: rgb(0,0,255)">do</SPAN> {
            <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_inputClosed) {
                <SPAN style="COLOR: rgb(0,0,255)">throw</SPAN> <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">InvalidOperationException</SPAN>(<SPAN style="COLOR: rgb(163,21,21)">"Input end of pipe is closed"</SPAN>);
            }
            <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> originalStack = m_writerStack;
            <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> newStack = originalStack.Push(value);
            <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> currentStack = <SPAN style="COLOR: rgb(43,145,175)">Interlocked</SPAN>.CompareExchange(<SPAN style="COLOR: rgb(0,0,255)">ref</SPAN> m_writerStack, newStack, originalStack);
            done = <SPAN style="COLOR: rgb(0,0,255)">object</SPAN>.ReferenceEquals(currentStack, originalStack);
        } <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (!done);
        m_event.Set();
    }
    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> CloseInput() {
        m_inputClosed = <SPAN style="COLOR: rgb(0,0,255)">true</SPAN>;
    }</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>[1] If you haven't read this series you really should.&nbsp; </P></div>
    