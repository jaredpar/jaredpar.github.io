<p>For previous articles in this series please see ...</p> <ul> <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/04/27/closures-in-vb-part-1.aspx">Part 1: Introduction</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/05/03/closures-in-vb-part-2-method-calls.aspx">Part 2: Method Calls</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/05/25/closures-in-vb-part-3-scope.aspx">Part 3: Scope</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/06/15/closures-in-vb-part-4-variable-lifetime.aspx">Part 4: Variable Lifetime</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/07/26/closures-in-vb-part-5-looping.aspx">Part 5: Looping</a></li></ul> <p>As powerful as closures are in the language they do have a few limitations.&nbsp; We worked hard in Orcas to put as few limitations in Orcas as possible.&nbsp; Below are the current limitations and some insight into why they exist this way.&nbsp; </p> <p>1. Cannot use "ByRef" parameters in a closure</p> <p>Example:</p><pre>    <span style="color: blue">Sub</span> LiftAByRef(<span style="color: blue">ByRef</span> x <span style="color: blue">As</span> <span style="color: blue">Integer</span>)
        <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() x
    <span style="color: blue">End</span> <span style="color: blue">Sub</span></pre>
<p>Message: error BC36639: 'ByRef' parameter 'x' cannot be used in a lambda expression.</p>
<p>The problem here is the expectation surrounding x.&nbsp; Any change in the value of "x" inside the method "LiftAByRef" should be reflected in the calling function.&nbsp;&nbsp; Normally for any lifted parameter we add a new field inside the closure and all read/writes are redirected into that value.&nbsp; For "ByRef" parameters we would additionally have to ensure that all writes are make to the parameter.&nbsp; Even in the presence of an exception.&nbsp; Not a trivial task.&nbsp; </p>
<p>2. Cannot use "Me" in a closure created inside a structure.&nbsp; </p>
<p>Example:</p><pre><span style="color: blue">Structure</span> S1
    <span style="color: blue">Public</span> F1 <span style="color: blue">As</span> <span style="color: blue">Integer</span>

    <span style="color: blue">Public</span> <span style="color: blue">Sub</span> M1()
        <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() F1
    <span style="color: blue">End</span> <span style="color: blue">Sub</span>
<span style="color: blue">End</span> <span style="color: blue">Structure</span>
</pre>
<p>Message: error BC36638: Instance members and 'Me' cannot be used within a lambda expression in structures</p>
<p>Closures capture values by reference.&nbsp; It's not possible to capture the "Me" of a structure by reference in VB.&nbsp; The only other option is to capture them by value.&nbsp; If we did that then all changes to members of a structure inside a lambda would not affect the structure in which they were created; merely the value copy.&nbsp; This is very different behavior from every other place that closures are used.&nbsp; To avoid confusing behavior this is not a legal operation.&nbsp; </p>
<p>3. Cannot use a Restricted Type in a closure</p>
<p>Example:</p><pre>    <span style="color: blue">Sub</span> LiftRestrictedType()
        <span style="color: blue">Dim</span> x <span style="color: blue">As</span> ArgIterator = <span style="color: blue">Nothing</span>
        <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() x.GetNextArgType().GetModuleHandle()
    <span style="color: blue">End</span> <span style="color: blue">Sub</span>
</pre>
<p>Message: error BC36640: Instance of restricted type 'System.ArgIterator' cannot be used in a lambda expression.</p>
<p>This hopefully will not affect many users.&nbsp; There are several types in the CLR that are considered <em>restricted</em> because they have special semantics.&nbsp; Typically they are special cased by the CLR and as such we can't use them in a closure.&nbsp; Several of these cannot be used in VB at all.&nbsp; They are ...</p>
<ul>
<li>System.TypedReference 
<li>System.ArgIterator 
<li>System.RuntimeArgumentHandle</li></ul>
<p>4. Cannot Goto&nbsp;into scope that contains a closure </p>
<p>Example:</p><pre>    <span style="color: blue">Sub</span> BadGoto()
        <span style="color: blue">Dim</span> x = <span style="color: maroon">0</span>

        <span style="color: blue">GoTo</span> Label1
        <span style="color: blue">If</span> x &gt; <span style="color: maroon">5</span> <span style="color: blue">Then</span>
Label1:
            <span style="color: blue">Dim</span> y = <span style="color: maroon">5</span>
            <span style="color: blue">Dim</span> f = <span style="color: blue">Function</span>() y
        <span style="color: blue">End</span> <span style="color: blue">If</span>
    <span style="color: blue">End</span> <span style="color: blue">Sub</span></pre>
<p>Message: error BC36597: 'GoTo Label1' is not valid because 'Label1' is inside a scope that defines a variable that is used in a lambda or query expression.</p>
<p>If you look back at <a href="http://blogs.msdn.com/jaredpar/archive/2007/05/25/closures-in-vb-part-3-scope.aspx">Part 3</a>&nbsp;of this series you will see that a lot of work goes into initializing closures inside of a scope.&nbsp; Unfortunately allowing a user to jump into a block that contains a closure makes respecting these rules very difficult.&nbsp; In a even trivial example in makes the resulting code mostly unreadable.&nbsp; We decided to disable this in Orcas and reconsider it in a future release.</p>
<p>It is perfectly legal however to jump into any scope that is currently visible regardless of whether or not in contains a closure.&nbsp; Because jumping into a visible scope does not affect the creation of a variable lifetime (just the ending), it does not add any complications to the code.&nbsp; </p>
<p>5. Cannot mix "On Error Goto" and Closures</p>
<p>Message: error BC36595: Method cannot contain both an 'On Error GoTo' statement and a lambda or query expression.</p>
<p>Because of restriction #4 we must disable this scenario as well since it's very easy to hit this scenario with "On Error Goto".&nbsp; </p></div>
    