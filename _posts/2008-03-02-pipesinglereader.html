<P>Before we can get to building an Active Object implementation, there are some more primitive structures we need to define.&nbsp; Active Objects live on a separate thread where every call is executed in a serialized fashion on that thread.&nbsp; The next primitive will allow us to easily pass messages in the form of delegates from the caller to the background thread.&nbsp; </P>
<P>The structure must support adding messages from N callers but only needs to support 1 reader (the active object).&nbsp; Successive writes from the same thread should add the items in their respective order.&nbsp; The input end of the pipe can be closed while leaving the output end active.&nbsp; This allows for the consumer to deterministically reach an end state while not ignoring any any input.</P>
<P>The name of the structure is PipeSingleReader.</P>
<P>Designing a thread safe mutable structure is significantly different from a non-thread safe or immutable data structure.&nbsp; There is a significant temptation to apply existing patterns.&nbsp; We should question every pattern we apply to these collections.&nbsp; Many of these patterns lead us to design API's which encourage bad programming practices. </P>
<P>Our existing collection patterns are designed around structures which behave deterministically on any given thread because they are 1) Immutable or 2) designed for single thread use only.&nbsp; Many of these concepts do not apply to mutable thread safe collections because they are constantly being accessed and mutated by multiple threads.&nbsp; This gives them the <EM>appearance </EM>of behaving non-deterministically with respect to a given thread.&nbsp; </P>
<P>Take the member Count for instance.&nbsp; This is found on virtually every collection class in the BCL.&nbsp; Yet having it on a mutable thread safe collection class only leads to programming errors.&nbsp; The only reason to have a member such is Count is to use it to make a decision.&nbsp;&nbsp; However in a mutable thread-safe collection making a decision off of this value is wrong.&nbsp; The value can and will change between any two instructions in code.&nbsp; </P>
<P>Take the example below.&nbsp; Just because the Count is &gt;0 in the if block has no dependable relevance to what the value will be inside the if block.&nbsp; </P><PRE class=code>            <SPAN style="COLOR: rgb(0,0,255)">var</SPAN> ThreadSafeList&lt;<SPAN style="COLOR: rgb(0,0,255)">int</SPAN>&gt; col = GetList();
            <SPAN style="COLOR: rgb(0,0,255)">if</SPAN>( col.Count &gt; 0 )
            {
                <SPAN style="COLOR: rgb(0,128,0)">//...
</SPAN>            }</PRE>
<P>To guard against this and have users of the collections avoid the pit of failure members such as Count should not appear on mutable thread-safe collections.&nbsp; </P>
<P>Instead we'll design API's around the functionality of this structure.&nbsp; The input end of the structure is straight forward.&nbsp; All writers want is to add data.&nbsp; </P>
<P>The output end is more interesting.&nbsp; The end goal is to read output from the pipe but how to deal with cases where there is no data.&nbsp;&nbsp; Some programs will want to check for data, others block until data is available.&nbsp;&nbsp; We can define three methods to satisfy most scenarios</P>
<UL>
<LI>WaitForOutput - void method which blocks until input is available</LI>
<LI>GetNextOutput - Blocks until input is available and returns it</LI>
<LI>TryGetOutput - Returns immediately.&nbsp; If output is available it will be returned.</LI></UL><PRE class=code>    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">class</SPAN> <SPAN style="COLOR: rgb(43,145,175)">PipeSingleReader</SPAN>&lt;T&gt; : <SPAN style="COLOR: rgb(43,145,175)">IDisposable</SPAN> {
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ThreadAffinity</SPAN> m_affinity = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">ThreadAffinity</SPAN>();
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Queue</SPAN>&lt;T&gt; m_queue = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Queue</SPAN>&lt;T&gt;();
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(43,145,175)">AutoResetEvent</SPAN> m_event = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">AutoResetEvent</SPAN>(<SPAN style="COLOR: rgb(0,0,255)">false</SPAN>);
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">readonly</SPAN> <SPAN style="COLOR: rgb(0,0,255)">object</SPAN> m_lock = <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(0,0,255)">object</SPAN>();
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> m_inputClosed;

        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> PipeSingleReader() {
        }

<SPAN style="COLOR: rgb(0,0,255)">        #region</SPAN> Dispose
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> Dispose() {
            Dispose(<SPAN style="COLOR: rgb(0,0,255)">true</SPAN>);
            <SPAN style="COLOR: rgb(43,145,175)">GC</SPAN>.SuppressFinalize(<SPAN style="COLOR: rgb(0,0,255)">this</SPAN>);
        }
        ~PipeSingleReader() {
            Dispose(<SPAN style="COLOR: rgb(0,0,255)">false</SPAN>);
        }
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> Dispose(<SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> disposing) {
            <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (disposing) {
                m_event.Close();
            }
        }
<SPAN style="COLOR: rgb(0,0,255)">        #endregion
</SPAN>        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> WaitForOutput() {
            m_affinity.Check();
            <SPAN style="COLOR: rgb(0,0,255)">do</SPAN> {
                <SPAN style="COLOR: rgb(0,0,255)">lock</SPAN> (m_lock) {
                    <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_queue.Count &gt; 0) {
                        <SPAN style="COLOR: rgb(0,0,255)">return</SPAN>;
                    }
                }
                m_event.WaitOne();
            } <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (<SPAN style="COLOR: rgb(0,0,255)">true</SPAN>);
        }
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> T GetNextOutput() {
            m_affinity.Check();
            T data;
            <SPAN style="COLOR: rgb(0,0,255)">while</SPAN> (!TryGetOutput(<SPAN style="COLOR: rgb(0,0,255)">out</SPAN> data))
            {
                m_event.WaitOne();
            } 
            <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> data;
        }
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">bool</SPAN> TryGetOutput(<SPAN style="COLOR: rgb(0,0,255)">out</SPAN> T value) {
            m_affinity.Check();
            <SPAN style="COLOR: rgb(0,0,255)">lock</SPAN> (m_lock) {
                <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_queue.Count == 0) {
                    value = <SPAN style="COLOR: rgb(0,0,255)">default</SPAN>(T);
                    <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(0,0,255)">false</SPAN>;
                }

                value = m_queue.Dequeue();
                <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(0,0,255)">true</SPAN>;
            }
        }
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> AddInput(T value) {
            <SPAN style="COLOR: rgb(0,0,255)">lock</SPAN> (m_lock) {
                <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (m_inputClosed) {
                    <SPAN style="COLOR: rgb(0,0,255)">throw</SPAN> <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">InvalidOperationException</SPAN>(<SPAN style="COLOR: rgb(163,21,21)">"Input end of pipe is closed"</SPAN>);
                }
                m_queue.Enqueue(value);
            }
            m_event.Set();
        }
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">void</SPAN> CloseInput() {
            <SPAN style="COLOR: rgb(0,0,255)">lock</SPAN> (m_lock) {
                m_inputClosed = <SPAN style="COLOR: rgb(0,0,255)">true</SPAN>;
            }
        }
    }</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>At a quick glance it may seem odd in GetNextOutput that I loop around m_event being set and TryGetOutput.&nbsp; Why loop?&nbsp; Shouldn't a single check for the settness of m_event be enough?&nbsp; In this case no.&nbsp; The reason why is TryGetOutput will remove output from the queue without resetting the settness of m_event.&nbsp; Thus m_event can be set without actually having any data in m_queue.&nbsp; In general the implementation must treat m_event being set as the possibility of data rather than a guarantee.&nbsp; </P>
<P>This implementation uses locks to synchronize access to the data.&nbsp; In general I'm a fan of avoiding locks when possible since it's very easy to miss trivial cases.&nbsp; Next time we'll look at an implementation of PipeSingleReader which avoids the use of locks.&nbsp; </P></div>
    