<p>The 5.0 release of C# introduced the await keyword which makes it extremely easy to use Task&lt;T&gt; in a non-blocking fashion.&#160; This allows developers to replace either blocking calls to Task.Wait() or complicated combinations of ContinueWith and callbacks with a nice simple, straight forward expression</p>  <pre class="code"><span style="background: white; color: black;">        </span><span style="background: white; color: rgb(43, 145, 175);">Task</span><span style="background: white; color: black;">&lt;</span><span style="background: white; color: blue;">int</span><span style="background: white; color: black;">&gt; task = ...;
        </span><span style="background: white; color: blue;">int </span><span style="background: white; color: black;">local = </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">task;
        Use(local);
</span></pre>

<p>What most people don’t consider is the implications of this non-blocking support.&#160; At the point the ”<span style="background: white; color: blue;">await </span><span style="background: white; color: black;">task” </span>expression executes the program can do one of two things.&#160; If task is resolved the await expression will complete and the method will continue executing immediately.&#160; If it’s not then the method will pause and some other part of the program will wake up and start running.&#160; This other code interleaves with with the execution of this method.&#160; This means subtle timing changes in when Task values are resolved can drastically alter the order in which a program executes. </p>

<p>These method interleavings can be the source of many subtle bugs in the program.&#160; They are typically timing related and hence often don’t predictably reproduce and possibly don’t show up at all until the program is executing on a customers machine.&#160; One of the most common bugs I see is when developers mistakenly combine compound assignment with the await keyword </p>

<pre class="code"><span style="background: white; color: black;">        x += </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">y;
</span></pre>

<p>The C# compiler will rewrite this code into roughly the following [1] </p>

<pre class="code"><span style="background: white; color: black;">        x = x + </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">y;
</span></pre>

<p>And it executes in the following steps</p>

<ol>
  <li>load x onto the stack </li>

  <li>await y </li>

  <li>Push result of “await y” onto the stack </li>

  <li>Add the stack values </li>

  <li>Store into x</li>
</ol>

<p>In the case where “y” isn’t resolved the execution of this code will stop at step #2.&#160; At which point some other code will begin executing in its place.&#160; If “x” is a local there isn’t much danger here but what if “x” represents a field that is accessible to another part of the program?&#160; And what if that field is modified while this expression is paused at #2?&#160; When this statement resumes it will never re-read the value of “x” and hence any writes to it which occurred during the pause will be erased once the expression completes.&#160; Or in other words, it will quite simply ignore the other write.&#160; </p>

<p>I most frequently see this problem with accumulator scenarios.&#160; A collection of tasks are spun up and the results are tallied up as they complete </p>

<pre class="code"><span style="background: white; color: black;">    </span><span style="background: white; color: blue;">class </span><span style="background: white; color: rgb(43, 145, 175);">Accumulator
    </span><span style="background: white; color: black;">{
        </span><span style="background: white; color: blue;">private int </span><span style="background: white; color: black;">m_sum;

        </span><span style="background: white; color: blue;">public int </span><span style="background: white; color: black;">Sum
        {
            </span><span style="background: white; color: blue;">get </span><span style="background: white; color: black;">{ </span><span style="background: white; color: blue;">return </span><span style="background: white; color: black;">m_sum; }
        }

        </span><span style="background: white; color: blue;">public async </span><span style="background: white; color: rgb(43, 145, 175);">Task </span><span style="background: white; color: black;">Add(</span><span style="background: white; color: rgb(43, 145, 175);">Task</span><span style="background: white; color: black;">&lt;</span><span style="background: white; color: blue;">int</span><span style="background: white; color: black;">&gt; value)
        {
            m_sum += </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">value;
        }
    }
</span></pre>

<p>This code is fundamentally incorrect because it invites this very problem.&#160; Consider the following scenario </p>

<ol>
  <li>Call to Add is made with an unresolved Task.&#160; Add pauses on the task having already read m_sum onto the stack</li>

  <li>Call to Add is made with a resolved Task with a value of 4.&#160; Add completes and m_sum is now 4 </li>

  <li>Task from step 1 resolves with a value of 2.&#160; The value on the stack for m_sum is still 0 so m_sum is written out as 2 instead of 6 </li>
</ol>

<p>&#160;</p>

<p>The way to avoid this problem is to simply not mix await and the compound operator.&#160; Instead store the await value into a temp and then do the assignment without the risk of interleavings. </p>

<p>&#160;</p>

<pre class="code"><span style="background: white; color: black;">        </span><span style="background: white; color: blue;">public async </span><span style="background: white; color: rgb(43, 145, 175);">Task </span><span style="background: white; color: black;">Add(</span><span style="background: white; color: rgb(43, 145, 175);">Task</span><span style="background: white; color: black;">&lt;</span><span style="background: white; color: blue;">int</span><span style="background: white; color: black;">&gt; value)
        {
            </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">temp = </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">value;
            m_sum += temp;
        }
</span></pre>

<p>&#160;</p>

<p>Here is a sample which will demonstrate the bug in a deterministic fashion.&#160; </p>

<pre class="code"><span style="background: white; color: black;">        </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">accumulator = </span><span style="background: white; color: blue;">new </span><span style="background: white; color: rgb(43, 145, 175);">Accumulator</span><span style="background: white; color: black;">();
        </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">taskCompletionSource1 = </span><span style="background: white; color: blue;">new </span><span style="background: white; color: rgb(43, 145, 175);">TaskCompletionSource</span><span style="background: white; color: black;">&lt;</span><span style="background: white; color: blue;">int</span><span style="background: white; color: black;">&gt;();
        </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">taskCompletionSource2 = </span><span style="background: white; color: blue;">new </span><span style="background: white; color: rgb(43, 145, 175);">TaskCompletionSource</span><span style="background: white; color: black;">&lt;</span><span style="background: white; color: blue;">int</span><span style="background: white; color: black;">&gt;();

        </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">task1 = accumulator.Add(taskCompletionSource1.Task);
        </span><span style="background: white; color: blue;">var </span><span style="background: white; color: black;">task2 = accumulator.Add(taskCompletionSource2.Task);
        taskCompletionSource2.SetResult(3);
        taskCompletionSource1.SetResult(2);

        </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">task1;
        </span><span style="background: white; color: blue;">await </span><span style="background: white; color: black;">task2;

        </span><span style="background: white; color: rgb(43, 145, 175);">Console</span><span style="background: white; color: black;">.WriteLine(accumulator.Sum);
</span></pre>

<p>This code will print out 2 instead of the expected 5 </p>

<p>[1] I use “roughly” here because it the compiler actually does a more complicated rewrite.&#160; It ensures that the side effects of “x” happen exactly once during the execution of this method.&#160; For locals though this is roughly the code that is generated and serves fine for this example&#160; </p><div style="clear:both;"></div></div>
    