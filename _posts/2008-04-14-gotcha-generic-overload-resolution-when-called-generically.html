<p>Both VB and C# have a feature of generic overload resolution that is fairly helpful and yet a source of gotchas.&nbsp; Lets say you have two methods with the same number of arguments.&nbsp; One method has arguments with generic types and the other does not.&nbsp; For Example:</p><pre class="code">    <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">C1</span>&lt;T&gt; {
        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> F1(<span style="color: rgb(0,0,255)">int</span> ival) {
            <span style="color: rgb(43,145,175)">Console</span>.WriteLine(<span style="color: rgb(163,21,21)">"Non-generic F1"</span>);
        }
        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> F1(T val) {
            <span style="color: rgb(43,145,175)">Console</span>.WriteLine(<span style="color: rgb(163,21,21)">"Generic F1"</span>);
        }
    }</pre><a href="http://11011.net/software/vspaste"></a>
<p>Imagine what happens when we have a C1&lt;int&gt; and call F1(5).&nbsp; Which method should the compiler bind to?&nbsp; Both VB and C# when presented with this type of situation will choose the non-generic version.&nbsp; </p><pre class="code">            v1.F1(5);           <span style="color: rgb(0,128,0)">// Binds to Non-generic F1
</span>            v2.F1(<span style="color: rgb(163,21,21)">"foo"</span>);       <span style="color: rgb(0,128,0)">// Binds to Generic F1</span></pre>
<p>At a glance we might think that we can provide specialized behavior for a subset of types that are interesting (similar to C++ template specialization).&nbsp; If VB/C# will bind to our non-generic version then we don't have to due ugly type switching to implement different behavior for certain types.&nbsp; Unfortunately we would be wrong.&nbsp; </p>
<p>This type of overload resolution only happens if the compiler can statically verify that the argument matches a non-generic overload.&nbsp; So if we call F1 generically it will not bind to the non-generic overload.&nbsp; </p><pre class="code">        <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> TestOverload&lt;T&gt;(<span style="color: rgb(43,145,175)">C1</span>&lt;T&gt; weird, T value) {
            weird.F1(value);
        }

        <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> Main(<span style="color: rgb(0,0,255)">string</span>[] args) {
            <span style="color: rgb(0,0,255)">var</span> v1 = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">C1</span>&lt;<span style="color: rgb(0,0,255)">int</span>&gt;();
            <span style="color: rgb(0,0,255)">var</span> v2 = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">C1</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt;();

            TestOverload(v1, 5);        <span style="color: rgb(0,128,0)">// Binds to Generic F1
</span>            TestOverload(v2, <span style="color: rgb(163,21,21)">"foo"</span>);    <span style="color: rgb(0,128,0)">// Binds to Generic F1
</span>        }</pre><pre class="code">&nbsp;</pre></div>
    