<p>Shortly after Visual Studio 2010 shipped I wanted to experiment with the new VSIX format for traditional Package extensions.&#160; I fired up my copy of Visual Studio, ran through the new package project wizard.&#160; But instead of a nice shiny new project I was greeted with a project load error dialog.&#160; After a bit of investigation I found the generated project file was corrupt.&#160; The majority of the template code was not replaced. </p>  <p>A bit disturbed that we shipped such a bug I immediately fired an email off to the appropriate team and inquired about the situation.&#160; I got back a very quick psychic debugging response.&#160; </p>  <blockquote>   <p>Do you have any extensions installed on the machine?&#160; </p> </blockquote>  <p>After a quick check I verified the only extension on my machine was my very own <a href="http://visualstudiogallery.msdn.microsoft.com/en-us/59ca71b3-a4a3-46ca-8fe1-0e90e3f79329">VsVim</a> project.&#160; I naturally assumed this couldn’t be any fault of VsVim because it doesn’t participate&#160; in project creation and no other project type was affected.&#160; Imagine my surprise then that after uninstalling VsVim everything started working as expected.&#160; After a few more verification runs, and a bit of self shame, I realized it indeed was my problem and got out the debugger.&#160; </p>  <p>It turns out the package wizard does project file substitution a bit differently than the project project templates.&#160; It uses the <a href="http://msdn.microsoft.com/en-us/library/envdte(VS.80).aspx">DTE object model</a> to do the replacements.&#160; DTE is different than the other VSIP interfaces in that it is intended to participate in automation (aka Macros).&#160;&#160; Operations tend to avoid manipulating the buffer directly but instead raise a command which is later handled by another component in the editor.&#160; Using the command system allows DTE to participate in automation.&#160; </p>  <p>For example operations like <a href="http://msdn.microsoft.com/en-us/library/envdte.textselection.delete(VS.80).aspx">TextSelection.Delete</a> don’t directly delete text from the buffer.&#160; Instead it just raises the command which represents the user hitting the delete key which is eventually handled by the editor and deletes the selection.&#160; These commands are processed through the <a href="http://msdn.microsoft.com/en-us/library/ms683797(VS.85).aspx">IOleCommandTarget</a> chain for a given IVsTextView.&#160; </p>  <p>Once I found out this it became immediately apparent what was happening.&#160; The package wizard is effectively sending keystrokes to a buffer with the intend of performing edits.&#160; VsVim uses <a href="http://msdn.microsoft.com/en-us/library/ms683797(VS.85).aspx">IOleCommandTarget</a> to intercept key strokes and was happily treating them as Vim commands.&#160; </p>  <p>The implications are even further reaching than just the package wizard.&#160; Macros primarily operate on the DTE object model hence I was also breaking them (very badly indeed).&#160; </p>  <p>Luckily there is a very simply fix to the problem.&#160; Visual Studio provides a nice helper method which allows you to determine if you are currently in the middle of automation.&#160; Adding a <a href="http://github.com/jaredpar/VsVim/commit/df0b6e6c1c95ff53acc14cbd5ad3cf5ccca05cd0">simple check</a> for this at my IOleCommandTarget entry points cleared up the issues nicely.&#160; </p>  <pre class="code"><span style="color: blue">if </span>(<span style="color: #2b91af">VsShellUtilities</span>.IsInAutomationFunction(_serviceProvider))
{
    <span style="color: blue">return false</span>;
}</pre>
In general any component in the IOleCommandTarget chain should be making the same check on both QueryStatus and Exec.&#160; Unless your component is specifically designed for macros and automations handling a command during automation will lead to hard to track down issues.&#160; <div style="clear:both;"></div></div>
    