<p>Recently I had a half day adventure trying to catch a SafeIntException in code I was writing.&nbsp; The particular function involved a bit of math with user controlled values.&nbsp; Writing a bunch of IfFailGo's with several TryAdd style API's was getting tiresome so I decided to just use SafeInt, catch an overflow and return a failure code.&nbsp; </p> <p>After recompiling the code I got an error because I hadn't enabled C++ exception handling in the project.&nbsp; Fix to support synchronous exceptions (/Ehs), recompile.&nbsp; Now I get a different error because a portion of the code base is using SEH exception handling.&nbsp; No problem, changed the project to support asynchronous exception handling as well (/Eha).&nbsp; And yet again another error, the compiler now said that I could not use variables with a destructor in the same method that had an SEH try block.&nbsp; </p> <p>This put me in a bit of a corner.&nbsp; The code base is littered with SEH exception handling and much of it is perfectly valid.&nbsp; Luckily the number of places using both SEH and destructors was fairly limited.&nbsp; What I needed was a way to unify the exception handling to allow me to use destructors in the same place as SEH exceptions.</p> <p>With /Eha there is a built-in way.&nbsp; You can catch all SEH exceptions using the C++ syntax "catch (...)".&nbsp; However this method is limiting because you cannot access the SEH exception code and you get notified after the stack unwind occurs.&nbsp; In SEH an exception filter is run before a stack unwind occurs which makes it infinitely easier to track down your bugs as you can just look down the stack trace and see the line of code that faulted.</p> <p>After a bit of research I found a solution.&nbsp; I'm chose to blog about it because many of the questions I needed answers for were either 1) undocumented or 2) documented to vaguely.&nbsp; In the end I setup some experiment projects to confirm the behaviors I expected.&nbsp; </p> <p>The magic function I was looking for was <a href="http://msdn2.microsoft.com/en-us/library/5z4bw5h5(VS.80).aspx">_set_se_translator</a>.&nbsp; It takes a function pointer as an argument and returns the previous value.&nbsp; The documentation states that when a C/SEH exception is raised this function pointer is called once per function that has a C++ try block.&nbsp; It can be used to throw a C++ exception in place of a SEH exception.&nbsp; So you can now translate a SEH exception into a C++ one.</p> <p>What the documentation didn't explain (and I was very curious about) is how this interweaves with existing SEH __try/__except/__finally blocks.&nbsp; After some experimentation I discovered that it works extremely well.&nbsp; SEH exceptions occur in two phases</p> <ol> <li>Process the exception filters until either EXCEPTION_EXECUTE_HANDLER or EXCEPTION_CONTINUE_EXECUTION is returned</li> <li>If EXECEPTION_EXECUTE_HANDLER is returned the stack is unwound to the point of the exception handler block and it is then executed.&nbsp; </li></ol> <p>The value passed to <a href="http://msdn2.microsoft.com/en-us/library/5z4bw5h5(VS.80).aspx">_set_se_translator</a> participates in phase 1 of the process.&nbsp; As the CRT is looking down the stack for a SEH exception filter, if it finds a C++ try block it will also process the last value passed to <a href="http://msdn2.microsoft.com/en-us/library/5z4bw5h5(VS.80).aspx">_set_se_translator</a> and allow it to throw a C++ exception.&nbsp; If an exception is thrown the stack is unwound to that point and then the exception is thrown.&nbsp; This means that if you call into other code which uses traditional SEH handlers they will operate just as they did before you started using <a href="http://msdn2.microsoft.com/en-us/library/5z4bw5h5(VS.80).aspx">_set_se_translator</a>.&nbsp; Most importantly __finally blocks will run and __except blocks above you in the stack still process and can handle SEH exceptions.&nbsp; </p> <p>The next step was to write an easy to use wrapper for this functionality.&nbsp; I used two classes to implement this approach.&nbsp; </p> <p>The first class is designed to properly install a translator at a given point in the stack and ensure that it is reset to the previous value when that stack frame is popped off.&nbsp; </p><pre class="code"><span style="color: rgb(0,0,255)">extern</span> <span style="color: rgb(0,0,255)">void</span> SehTranslatorFunction(<span style="color: rgb(0,0,255)">unsigned</span> <span style="color: rgb(0,0,255)">int</span>, <span style="color: rgb(0,0,255)">struct</span> _EXCEPTION_POINTERS*);

<span style="color: rgb(0,0,255)">class</span> SehGuard
{
<span style="color: rgb(0,0,255)">public</span>:
    SehGuard()
    {
        m_prev = _set_se_translator(SehTranslatorFunction);
    }

    ~SehGuard()
    {
        _set_se_translator(m_prev);
    }

<span style="color: rgb(0,0,255)">private</span>:
    _se_translator_function m_prev;
};</pre>
<p>The second part is to actually throw an exception inside of SehTranslatorFunction.&nbsp; Also to add an assert so that when an SEH exception is produced I can break at the point of failure (as opposed to in the catch block where the stack will be unwound. </p><pre class="code"><span style="color: rgb(0,0,255)">class</span> SehException
{
<span style="color: rgb(0,0,255)">public</span>:
    SehException(<span style="color: rgb(0,0,255)">int</span> code) : m_code(code) { }
<span style="color: rgb(0,0,255)">private</span>:
    <span style="color: rgb(0,0,255)">unsigned</span> <span style="color: rgb(0,0,255)">int</span> m_code;
};</pre><a href="http://11011.net/software/vspaste"></a><pre class="code"><span style="color: rgb(0,0,255)">void</span> SehTranslatorFunction(<span style="color: rgb(0,0,255)">unsigned</span> <span style="color: rgb(0,0,255)">int</span> code, <span style="color: rgb(0,0,255)">struct</span> _EXCEPTION_POINTERS*)
{
    MyAssertFunction(<span style="color: rgb(0,0,255)">false</span>,<span style="color: rgb(163,21,21)">"Caught an SEH exception"</span>);
    <span style="color: rgb(0,0,255)">throw</span> SehException(code);
}</pre>Now whenever I hit a point where I want to guard against SEH exceptions, I just put and instance of SehGuard on the stack and catch SehException instances.&nbsp; No traditional SEH needed.&nbsp; </div>
    