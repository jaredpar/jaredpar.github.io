<p>Lately I’ve been playing quite a bit with F#.&#160; I have several hobby projects I’m working on that take up a bit of my time.&#160; But when I’m not playing around with F# I’m exploring ways to apply certain functional patterns to actual coding on the job and/or porting to my functional library: <a href="http://code.msdn.microsoft.com/RantPack">RantPack</a>.</p>  <p>Recently I’ve been playing around with continuations in F#.&#160; I thought this was a great topic to do a F# comparison with other languages.&#160; In this case C#.&#160; </p>  <p>Let’s examine a classic use of continuations: a right fold on a list.&#160; For a detailed explanation of fold right and the use of a continuation I suggest taking a look at <a href="http://lorgonblog.spaces.live.com/blog/cns!701679AD17B6D310!170.entry">Brian's discussion</a>.&#160; If you’re unfamiliar with continuations I highly suggest that you take a look at this post as Brian gives a great breakdown of continuations and their uses.</p>  <p>Here's a quick refresher on continuations by example.&#160; Fold right is an operation which reduces a sequence of elements into a single element by processing the list from right to left.&#160; It’s similar to the <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.aggregate.aspx">LINQ Aggregate</a> method except Aggregate operations left to right.&#160; </p>  <p>For this post we’ll be writing FoldRight against a sequence.&#160; I chose sequence vs. the traditional list because it’s present in both languages (F# = seq&lt;’a&gt;, C# = IEnumerable&lt;T&gt;).&#160; It is possible to other F# data structures in C# but the comparison is cleaner when using a type that is native to both languages. </p>  <p>Sequences are a left to right data structure so processing it right to left is not natural.&#160; After all, with a sequence all the developer has is current and whether or not there is a next element.&#160; Processing the list in a right to left fashion can be done by such acts as reversing the list, or doing a head recursive call.&#160; Both have their detractors. </p>  <p>Continuations are a different way to process the list.&#160; Instead of processing the list directly we process the list a single element at a time building up a continuation along the way.&#160; For each element a lambda expression is generated representing the work needed to be done for that element.&#160; The value calculated within the lambda will then be passed to the lambda calculated for the previous element.&#160; Once we hit the end of the list, we essentially have a chain of lambda expressions which process each element in the list in reverse order.&#160; All that is needed is to call the final lambda with the starting value and we will effectively process the list in reverse order.</p>  <p>Simple enough?&#160; Lets take a look at the code.&#160; </p>  <p><strong>F# Code</strong></p>  <pre class="code"><span style="color: blue">let </span>FoldRight combine (sequence:seq&lt;'a&gt;) acc = 
    <span style="color: blue">use </span>e = sequence.GetEnumerator()
    <span style="color: blue">let rec </span>inner cont = 
        <span style="color: blue">match </span>e.MoveNext() <span style="color: blue">with
            </span>| <span style="color: blue">true -&gt; 
                let </span>cur = e.Current
                inner (<span style="color: blue">fun </span>racc <span style="color: blue">-&gt; </span>cont (combine cur racc))
            | <span style="color: blue">false -&gt; </span>cont acc
    inner (<span style="color: blue">fun </span>x <span style="color: blue">-&gt; </span>x )</pre>

<p><strong>C# Code</strong>&#160;</p>

<pre class="code"><span style="color: blue">public static </span>TAcc FoldRight&lt;TSource, TAcc&gt;(
    <span style="color: blue">this </span><span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; enumerable, 
    <span style="color: #2b91af">Func</span>&lt;TAcc, TSource, TAcc&gt; combine, 
    TAcc start) {

    <span style="color: blue">using </span>(<span style="color: blue">var </span>e = enumerable.GetEnumerator()) {
        <span style="color: #2b91af">Func</span>&lt;<span style="color: #2b91af">Func</span>&lt;TAcc, TAcc&gt;, TAcc&gt; inner = <span style="color: blue">null</span>;
        inner = (cont) =&gt; {
              <span style="color: blue">if </span>(e.MoveNext()) {
                  <span style="color: blue">var </span>cur = e.Current;
                  <span style="color: #2b91af">Func</span>&lt;TAcc, TAcc&gt; innerCont = (x) =&gt; cont(combine(x, cur));
                  <span style="color: blue">return </span>inner(innerCont);
              } <span style="color: blue">else </span>{
                  <span style="color: blue">return </span>cont(start);
              }
          };
        <span style="color: blue">return </span>inner(x =&gt; x);
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>My immediate reaction to the two samples is the conciseness of the F# code.&#160; This is a not a criticism of C# though.&#160; F# is designed to be a concise language and it’s delivery on that goal is evident in this sample.&#160; </p>

<p>What makes the big difference here is the type inference power of F#.&#160; In the C# sample there are 6 explicit types listed in the code sample.&#160; The F# sample only has a single type listed.&#160; The compiler is able to infer and/or generate the rest of the signatures.&#160; F# also requires less explicit generic parameters 1 vs. 2 in C#.</p>

<p>The next big difference I see is the awkward way in which the inner lambda expression must be declared in C#.&#160; The lambda expression is called recursively in order to setup the continuation.&#160; In order to do that in C# the lambda must be declared and defined in separate expressions.&#160; Otherwise, a self reference of “inner” inside the body of “inner” will generate a used before defined warning from the compiler.&#160; </p>

<p><strong>The IL</strong></p>

<p>Examining the full IL of both functions would take several blog posts.&#160; Not to mention that trying to read disassembled F# much less IL, is like trying to read disassembled C++.&#160; An interesting exercise but a bit time consuming.&#160; </p>

<p>I did want to focus a bit on one portion of the generated IL.&#160; There is a very significant difference in the way the recursive call to the “inner” lambda is made.&#160; </p>

<p>F#</p>

<pre class="code">    L_0032: ldarg.1 
    L_0033: ldarg.0 
    L_0034: ldfld !0 Test/clo@6T<!U, !A, !V>::acc
    L_0039: tail 
    L_003b: callvirt instance !1 [FSharp.Core]Microsoft.FSharp.Core.FastFunc`2<!U, !V>::Invoke(!0)</pre>

<p>C#</p>

<pre class="code">    
    L_0077: ldarg.0 
    L_0078: ldfld class [System.Core]System.Func`2<class  !1 [System.Core]System.Func`2><!1,>, !1&gt; ConsoleApplication1.Extensions/&lt;&gt;c__DisplayClass8<!TSource, !TAcc>::inner
    L_007d: ldloc.0 
    L_007e: callvirt instance !1 [System.Core]System.Func`2<class  !TAcc [System.Core]System.Func`2><!TAcc,>, !TAcc&gt;::Invoke(!0)
    L_0083: stloc.3 </pre>

<p>In both cases the first 3 lines are building up the 2 parameters necessary for the recursive lambda call.&#160; The closures are structured somewhat differently but the same basic operation is being done.&#160; </p>

<p>The key difference between the languages is F#’s use of the <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.tailcall(VS.95).aspx">tail opcode</a>.&#160; This opcode tells the CLR the to call the next method in a tail recursive fashion.&#160; This causes the CLR to remove the current method frame from the stack before the next method is called.&#160; Because the method is removed from the stack, the recursive call takes up no additional stack space.&#160; This is true no matter how many times the function is called.</p>

<p>The C# IL does not have this opcode.&#160; So the recursive call will happen with the current method on the frame.&#160; With a big enough sequence this will cause the process to run out of stack space and generate a StackOverflowException.&#160; This creates a limitation on the number of elements the C# sample can process.</p>

<p><strong>Limits</strong></p>

<p>I explored the limits of both samples on my home laptop.&#160; I generated a simple example to sum the sequence with the fold right.&#160; Note: For a sum of ints, a fold left is just as good, but it serves fine for this sample.</p>

<p>F#</p>

<pre class="code"><span style="color: blue">let </span>sum = FoldRight (<span style="color: blue">fun </span>x y <span style="color: blue">-&gt; </span>x + y) [1..1000000] 0
printfn <span style="color: maroon">&quot;%d&quot; </span>sum</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>C#</p>

<pre class="code"><span style="color: blue">var </span>source = <span style="color: #2b91af">Enumerable</span>.Range(1, 9397);
<span style="color: blue">var </span>result = source.FoldRight((x, y) =&gt; x + y, 0);
<span style="color: #2b91af">Console</span>.WriteLine(<span style="color: #a31515">&quot;{0}&quot;</span>, result);</pre>

<p>The C# sample can process a maximum size of 9397 elements.&#160; After that I encounter a stackoverflow exception. The F# sample however can easily process 1,000,000 elements. </p>

<p>Closing note.&#160; This not meant to be a post criticizing C#.&#160; It’s meant to be a general comparison of the same technique in two managed languages.&#160; This is a scenario that is far less likely to occur in a C# program.&#160; In an F# program it’s quite simply an expectation and hence the F# compiler is optimized for this scenario.&#160; </p></div>
    