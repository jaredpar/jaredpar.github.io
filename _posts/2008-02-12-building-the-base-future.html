<p>In the end there are two basic types of Future implementations you can use.</p>  <ol>   <li>Futures which return no values </li>    <li>Futures which return a value </li> </ol>  <p>The rest of the behavior and shape of the Future is the same and screams for a pattern of sorts.&#160; I've found the best way to implement this behavior is through an inheritance pattern.&#160; The base class is name of course Future.&#160; It's purpose is to provide a common way in which to schedule the invocation of a delegate, <a href="http://blogs.msdn.com/jaredpar/archive/2008/02/11/dealing-with-exceptions-in-a-future.aspx">handle exceptions</a>, wait for the completion of such delegate and enforce certain contracts such as not running the future more than once.</p>  <p>At the core it only needs a few members.</p>  <ol>   <li><a href="http://blogs.msdn.com/jaredpar/archive/2008/02/04/the-first-part-of-building-a-future-is-waiting.aspx">ActiveOperation</a> m_operation which is used to implement the waiting portion </li>    <li>int m_run used to ensure a future is not run twice </li>    <li>Exception m_error to record any exceptions thrown by running the delegate </li> </ol>  <pre class="code">        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">ActiveOperation</span> m_operation = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ActiveOperation</span>();
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">int</span> m_run;
        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">Exception</span> m_error;</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>It has one public property to determine whether or not a Future has completed.&#160; It's a proxy into m_operation</p>

<pre class="code">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">bool</span> HasCompleted
        {
            <span style="color: rgb(0,0,255)">get</span> { <span style="color: rgb(0,0,255)">return</span> m_operation.HasCompleted; }
        }</pre>

<p>By using m_operation to deal with Waiting, the majority of WaitEmpty can be proxied to m_operation as well.&#160; The only additional work needed is to deal with Exceptions.</p>

<pre class="code">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> WaitEmpty()
        {
            m_operation.Wait();
            <span style="color: rgb(0,0,255)">if</span> (m_error != <span style="color: rgb(0,0,255)">null</span>)
            {
                <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">FutureException</span>(<span style="color: rgb(163,21,21)">&quot;Error occurred running future&quot;</span>, m_error);
            }
        }</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>The only behavior a child class needs is a place to invoke the delegate.&#160; A single abstract method is provided to allow implement this behavior.</p>

<pre class="code">        <span style="color: rgb(0,0,255)">protected</span> <span style="color: rgb(0,0,255)">abstract</span> <span style="color: rgb(0,0,255)">void</span> RunCore();</pre>

<p>Before calling this method the base Future class must make sure that all of the contracts are met.&#160; This is implemented through a wrapper method around RunCore.&#160; It is the only method that calls RunCore directly.</p>

<pre class="code">        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">void</span> RunWrapper()
        {
            <span style="color: rgb(0,0,255)">if</span> (0 != <span style="color: rgb(43,145,175)">Interlocked</span>.CompareExchange(<span style="color: rgb(0,0,255)">ref</span> m_run, 1, 0))
            {
                <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">InvalidOperationException</span>(<span style="color: rgb(163,21,21)">&quot;Future is already run&quot;</span>);
            }

            <span style="color: rgb(0,0,255)">try
</span>            {
                RunCore();
            }
            <span style="color: rgb(0,0,255)">catch</span> (<span style="color: rgb(43,145,175)">Exception</span> ex)
            {
                <span style="color: rgb(43,145,175)">Interlocked</span>.Exchange(<span style="color: rgb(0,0,255)">ref</span> m_error, ex);
            }
            <span style="color: rgb(0,0,255)">finally
</span>            {
                m_operation.Completed();
            }
        }</pre>

<p><a href="http://11011.net/software/vspaste"></a>It's very important that m_operation is signalled as completed after exception handling occurs.&#160; The setting or not setting of m_error is the only way we know if an exception occurred when waiting.&#160; If we do this in the opposite order it's possible for WaitEmpty() to complete before the exception is set and hence miss the error.</p>

<p>Lastly is the code to actually run the Future.&#160; There are two ways to run the Future (more can be added).&#160; </p>

<ol>
  <li>Asynchronously through the ThreadPool.&#160; This is the more common case. </li>

  <li>Synchronously on the same thread.&#160; This will mainly be used to implement such operations as methods in Active Objects. </li>
</ol>

<pre class="code">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> Run()
        {
            RunWrapper();
        }

        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> RunInThreadPool()
        {
            <span style="color: rgb(43,145,175)">ThreadPool</span>.QueueUserWorkItem((x) =&gt; RunWrapper());
        }</pre>
This leaves us with a base class implementation for Future's.&#160; Next we'll implement Future which return values.&#160; </div>
    