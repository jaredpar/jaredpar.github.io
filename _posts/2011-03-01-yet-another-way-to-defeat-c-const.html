<p>One of my favorite C++ features, and one I feel is terribly underutilized in many code bases, is the <strong>const</strong> mechanism.&#160; It’s a great mechanism for defining dual roles for the same object type: a mutable and (ideally) non-mutable one.&#160; But as useful as <strong>const </strong>is it’s also very easy to circumvent and I’m always interested in learning new ways to do so. </p>  <p>While navigating through a stackoverflow <a href="http://stackoverflow.com/questions/5148656/c-how-can-we-call-delete-this-in-a-const-member-function">question</a> yesterday I came across yet another way to defeat C++ <strong>const</strong>.&#160; In C++ it’s perfectly legal to call delete on a <strong>const *</strong> value.&#160; This code path though transitions from a <strong>const * </strong>to a type to a <strong>non-const </strong>pointer by means of <strong>‘this’ </strong>in the destructor code.&#160; From there it’s possible to call any other mutable method in the type and bypass the original <strong>const</strong> without any nasty casts. For example</p>  <pre class="code"><span style="color: blue">class </span>Example {
<span style="color: blue">public</span>:
    ~Example() {
        MutableMethod();
    }
    <span style="color: blue">void </span>MutableMethod() {
        cout &lt;&lt; <span style="color: #a31515">&quot;Example::MutableMethod()&quot; </span>&lt;&lt; endl;
    }
    <span style="color: blue">void </span>ConstMethod() <span style="color: blue">const </span>{
        <span style="color: blue">delete this</span>;
    }
};</pre>

<p>With this type I can easily defeat <strong>const </strong>restrictions by simply deleting it </p>

<pre class="code"><span style="color: blue">const </span>Example* pLocal = <span style="color: blue">new </span>Example();
pLocal-&gt;ConstMethod();</pre>

<p>Granted this is not terribly useful when considering the <strong>const </strong>of the immediate type.&#160; It’s being deleted after all so messing around in it is unlikely to cause too much of a fuss.&#160; However it can be interesting when considering the access of nested members within the type which may live longer than the container being deleted.&#160; </p><div style="clear:both;"></div></div>
    