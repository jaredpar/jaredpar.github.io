<P>In my last post I went over the differences between using a <A href="http://blogs.msdn.com/jaredpar/archive/2008/11/10/comparing-continuations-in-f-and-c.aspx" mce_href="http://blogs.msdn.com/jaredpar/archive/2008/11/10/comparing-continuations-in-f-and-c.aspx">continuation in F# and C#</A>.&nbsp; As it turns out I was right about the limits and symptoms but wrong about the reason.&nbsp; </P>
<P>The F# code does indeed generate tail calls for part of the continuation.&nbsp; However this is only a very small portion of the actual code and is in fact only generated for the call in the empty case.&nbsp; I misread this function to be the call for the overall continuation.&nbsp; Instead it is the function for the entire “inner” lambda. </P>
<P>So why does F# perform differently than C# in this scenario? </P>
<P>Andrew Kennedy pointed out that F# will actually transform the “inner” function into a loop.&nbsp; In affect the code generated looks like the following. </P><PRE>    TypeFunc func = this._self3;
    while (true)
    {
        if (!this.e.MoveNext())
        {
            break;
        }
        A cur = this.e.Current;
        cont = new Program.clo@9&lt;U V, A ,&gt;(this.combine, cont, cur);
    }
    return cont.Invoke(this.acc);</PRE>
<P>The actual transformation into a loop is what is preventing F# from overflowing the stack here.&nbsp; Iteration incurs no stack overhead in this case.&nbsp; </P>
<P>Even more interesting is that the <A href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.tailcall(VS.71).aspx" mce_href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.tailcall(VS.71).aspx">tail opcode</A> is quite simply ignored when dealing with un-trusted code.&nbsp; It therefore cannot be relied on to generate performant code in all scenarios.&nbsp; </P></U></div>
    