<p>Today what started out as a crash due to a pure virtual call turned into finding a gotcha in CComPtrBase&lt;T&gt;.&nbsp; Essentially the code in question boiled down to the following.&nbsp; Can you spot the problem?</p><pre class="code"><span style="color: rgb(0,0,255)">void</span> GetAStudent(CComPtrBase&lt;T&gt; &amp;spStudent)
{
    CComPtr&lt;Student&gt; spLocal;
    <span style="color: rgb(0,128,0)">// Do some operation to get a student
</span>    spLocal = spStudent;
}</pre>
<p>The problem isn't apparent until you look at the definition for CComPtrBase&lt;T&gt;::operater =.&nbsp; See the problem?&nbsp; Basically CComPtrBase&lt;T&gt;::operator= isn't explicitly defined.&nbsp; This means that C++ will automatically implement <a href="http://msdn2.microsoft.com/en-us/library/x0c54csc(VS.71).aspx">memberwise assignment.</a>&nbsp; The RHS of the operator= will be a "const CComPtrBase&lt;T&gt;&amp;".&nbsp; </p>
<p>CComPtr&lt;T&gt; derives from CComPtrBase&lt;T&gt; therefore it satisfies this and a memberwise assignment will occur.&nbsp; We now have two smart pointers on the same value.&nbsp; However the second smart pointer, CComPtrBase&lt;T&gt;, did not perform an AddRef.&nbsp; So when both objects are destroyed there will be an extra Release and hopefully a crash.</p>
<p>The fix? </p>
<ol>
<li>Use CComPtr&lt;T&gt; or CComPtrEx&lt;T&gt; instead of CComPtrBase&lt;T&gt;</li>
<li>Less Optimal: call AddRef() on spLocal.&nbsp;&nbsp; </li></ol></div>
    