<p>Recently I ran into a situation on a personal project where I needed a hashtable like structure for a set of WeakReference values.&#160; When poking around for an existing implementation I saw found several versions which were very thin, type safe wrapper around a Dictionary&lt;TKey,WeakReference&gt; (usually the class even implements IDictionary&lt;TKey,TValue&gt; directly).&#160; While this produces a type safe API it fails to take into account the different nature of a WeakReference.&#160; Because a WeakReference is constantly being collected without explicit user action it alters the types of operations that be performed on them.&#160; Failing to take this into account produced APIs which lead users to write incorrect code.</p>  <p>Finding no suitable implementation I set off to build my own.&#160; It took several iterations and I thought the result and process would be fun to share the design experience as a blog post.&#160; </p>  <p>Let start with the basics.&#160; At a high level the API should appear to the user as a type safe Dictionary&lt;TKey,TValue&gt;.&#160; Under the hood all values will be stored in an instance of WeakReference in order to enable collection.&#160; But this is an implementation detail and should not be visible to the user.&#160;&#160; The user should only see type safe keys and values.</p>  <p>A standard Hashtable works on the concept of a key/value pair.&#160; A value is associated with a particular key in the table and at any time, the value can be retrieved from the hashtable with the specified key.&#160; A key can be determined to be valid simply by ascertaining it’s presence in the underlying table.&#160; The value is irrelevant, it’s mere presence makes it valid. </p>  <p>A weak hashtable will work on the same concept but have a much different implementation.&#160; Keys are only valid if they point to an actual value.&#160; Since the value in the hashtable is a WeakReference the mere presence of the key does not determine it’s validity.&#160; Only the presence of the key and the value contained within the weak reference determines the validity of a key.&#160; </p>  <p>This seems like an obvious assumption but it has a dramatic impact on the type of API a weak hashtable can have.&#160; Lets take a simple property such as Count for an example of why this is important.&#160; Count on a hashtable is used to determine the number of valid key/value pairs in the table.&#160; On a normal hashtable, this count is simply incremented and decremented with the corresponding Add and Remove API’s.&#160; With a weak hashtable, any given run of the garbage collector can affect the count of key/value pairs by collecting a value.&#160; This means a simple counter cannot be used to keep track of the valid key/value pairs.&#160; </p>  <p>In order to get the actual Count every singe value must be accessed an verified that it is still alive.&#160; What’s even worse is that once a value is determined to exist, it must be stored for the duration of the Count method.&#160; Otherwise a GC could occur in the middle of the loop and collect Values that were marked as still alive.&#160; </p>  <p>This is what Count would need to look like …&#160; </p>  <pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">WeakHashtable</span>&lt;TKey,TValue&gt; {
    <span style="color: blue">private </span><span style="color: #2b91af">Dictionary</span>&lt;TKey, <span style="color: #2b91af">WeakReference</span>&gt; _map;
    <span style="color: blue">public int </span>Count {
        <span style="color: blue">get </span>{
            <span style="color: blue">var </span>list = _map.Values
                .Select(x =&gt; x.Target)
                .Where(x =&gt; x != <span style="color: blue">null</span>)
                .ToList();
            <span style="color: blue">return </span>list.Count;
        }
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>Count transformed from a simple O(1) return of an internal counter to a O(N) method which allocates memory.&#160; Worse yet, the return value is practically useless.&#160; As soon as the value is returned it cannot be considered to be valid.&#160; A GC could kick in and invalidate half the table.&#160; Count would in fact be giving the user information about the object in the past.&#160; </p>

<p>In some ways, this problem is similar to issues encountered with multi-threaded applications.&#160; In between every line of your code there is another operation, in this case the GC, which can alter the state of your structure.&#160; </p>

<p>The only API’s that can ask questions about a value and still have a reasonable use by the user must return the value with the call.&#160; Returning the value will, at least temporarily, provide a GC root and prevent the object from being collected.&#160; It gives the user a chance to use the value before it’s taken out from under them. </p>

<p>A good API comparison here are operations such as Contains and TryGetValue.&#160; Contains holds no value to the user because as soon as the call returns the GC can collect the value.&#160; TryGetValue on the other hand returns the value in question thus locking it in memory and preventing a collection.&#160; </p>

<p>When designing the API for a weak hashtable I tried to keep it simple and stick to these ideas.&#160; I started with the <a href="http://msdn.microsoft.com/en-us/library/s4ys34ea.aspx">IDictionary&lt;TKey,TValue&gt;</a> interface and removed the methods which hold no value for the end user due to GC limitations.&#160; In the end I was left with only the following.</p>

<ul>
  <li>void Add(TKey key, TValue value) </li>

  <li>bool Remove(TKey key) </li>

  <li>void Clear() </li>

  <li>bool TryGetValue(TKey key, out TValue value) </li>

  <li>List&lt;TValue&gt; Values { get; } </li>
</ul>

<p>I also added the following methods</p>

<ul>
  <li>List&lt;Tuple&lt;TKey,TValue&gt;&gt; Pairs&#160; { get; } </li>

  <li>Put(TKey key, TValue value) </li>

  <li>Option&lt;TValue&gt; TryGetValue(TKey key); </li>
</ul>

<p>The Values property returns a List&lt;TValue&gt; implementation instead of IEnumerable&lt;TValue&gt;&#160; In order to guarantee the values remain in existence they must be rooted in some structure.&#160; The easy choice is a List&lt;TValue&gt;.&#160; Since a List&lt;TValue&gt; must be created anyways, why return a less accessible interface such as IEnumerable&lt;TValue&gt;?&#160; </p>

<p>At first I did consider a design where Values returned IEnumerable.&#160; It is fairly simple to implement with a C# iterator.&#160; </p>

<pre class="code"><span style="color: blue">public </span><span style="color: #2b91af">IEnumerable</span>&lt;TValue&gt; Values {
    <span style="color: blue">get </span>{
        <span style="color: blue">foreach </span>(<span style="color: blue">var </span>weakRef <span style="color: blue">in </span>_map.Values) {
            <span style="color: blue">var </span>obj = weakRef.Target;
            <span style="color: blue">if </span>(obj != <span style="color: blue">null</span>) {
                <span style="color: blue">yield return </span>(TValue)obj;
            }
        }
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>The problem though is that anything more than a simple .ForEach() over the IEnumerable may behave unexpectedly.&#160; Consecutive calls to GetEnumerator can produce different enumerations with no explicit user alteration of the table.&#160; I’ve seen several APIs which (rightly or wrongly) make this assumption.&#160; Given the user is not explicitly modifying the collection, it is not a necessarily bad assumption to make.&#160; However it would not work for a collection of this type.</p>

<p>I intentionally left off Keys here.&#160; Keys are only valid when they have a live value in the table.&#160; Unless the Value is returned with Key this cannot be guaranteed.&#160; The Pairs property serves this role.&#160; </p>

<p>This post went a bit longer than I originally intended.&#160; I also wanted to discuss how compaction of the table should work in a weak hashtable.&#160; I’ll save that for next time.&#160; </p>

<p>Here is the implementation of the dictionary without any compaction support.</p>

<pre class="code"><span style="color: blue">public sealed class </span><span style="color: #2b91af">WeakDictionary</span>&lt;TKey, TValue&gt; {
    <span style="color: blue">private </span><span style="color: #2b91af">Dictionary</span>&lt;TKey, <span style="color: #2b91af">WeakReference</span>&gt; m_map;

    <span style="color: blue">public </span><span style="color: #2b91af">List</span>&lt;<span style="color: #2b91af">Tuple</span>&lt;TKey, TValue&gt;&gt; Pairs {
        <span style="color: blue">get </span>{
            <span style="color: blue">return </span>m_map
                    .Select(p =&gt; <span style="color: #2b91af">Tuple</span>.Create(p.Key, p.Value.Target))
                    .Where(t =&gt; t.Second != <span style="color: blue">null</span>)
                    .Select(t =&gt; <span style="color: #2b91af">Tuple</span>.Create(t.First, (TValue)t.Second))
                    .ToList();
        }
    }

    <span style="color: blue">public </span><span style="color: #2b91af">List</span>&lt;TValue&gt; Values {
        <span style="color: blue">get </span>{ <span style="color: blue">return </span>Pairs.Select(x =&gt; x.Second).ToList(); }
    }

    <span style="color: blue">public </span>WeakDictionary()
        : <span style="color: blue">this</span>(<span style="color: #2b91af">EqualityComparer</span>&lt;TKey&gt;.Default) {
    }

    <span style="color: blue">public </span>WeakDictionary(<span style="color: #2b91af">IEqualityComparer</span>&lt;TKey&gt; comparer) {
        m_map = <span style="color: blue">new </span><span style="color: #2b91af">Dictionary</span>&lt;TKey, <span style="color: #2b91af">WeakReference</span>&gt;(comparer);
    }

    <span style="color: blue">public void </span>Add(TKey key, TValue value) {
        m_map.Add(key, <span style="color: blue">new </span><span style="color: #2b91af">WeakReference</span>(value));
    }

    <span style="color: blue">public void </span>Put(TKey key, TValue value) {
        m_map[key] = <span style="color: blue">new </span><span style="color: #2b91af">WeakReference</span>(value);
    }

    <span style="color: blue">public bool </span>Remove(TKey key) {
        <span style="color: blue">return </span>m_map.Remove(key);
    }

    <span style="color: blue">public </span><span style="color: #2b91af">Option</span>&lt;TValue&gt; TryGetValue(TKey key) {
        <span style="color: #2b91af">WeakReference </span>weakRef;
        <span style="color: blue">if </span>(!m_map.TryGetValue(key, <span style="color: blue">out </span>weakRef)) {
            <span style="color: blue">return </span><span style="color: #2b91af">Option</span>.Empty;
        }

        <span style="color: blue">var </span>target = weakRef.Target;
        <span style="color: blue">if </span>(target == <span style="color: blue">null</span>) {
            <span style="color: blue">return </span><span style="color: #2b91af">Option</span>.Empty;
        }

        <span style="color: blue">return </span>(TValue)target;
    }

    <span style="color: blue">public bool </span>TryGetValue(TKey key, <span style="color: blue">out </span>TValue value) {
        <span style="color: blue">var </span>option = TryGetValue(key);
        value = option.ValueOrDefault;
        <span style="color: blue">return </span>option.HasValue;
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a></div>
    