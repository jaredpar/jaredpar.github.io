<p>The short answer is: No, not when it matters</p>  <p>A colleague and I were discussing a particular scenario around IntPtr,PInvoke and 64 bit correctness.&#160; Eventually our discussion lead us to the IntPtr constructor which takes a long.&#160; To my surprise the code for the constructor is the following.</p>  <p>public unsafe <b><a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.IntPtr/.ctor(Int64)">IntPtr</a></b>(<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Int64">long</a> value) { this.<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.IntPtr/m_value:Void*">m_value</a> = (<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Void">void</a>*) ((<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Int32">int</a>) <a>value</a>); }</p>  <p>The problem is long value is arbitrarily truncated to an int.&#160; This has the effect of essentially losing any address over the 4 GB range (in other words, no 64 bit addresses).&#160; This much to big of a hole to actually be the real behavior so I decided to see if it was a bug in the disassembler.&#160; I was using .Net Reflector so I switched to IL mode.&#160; </p>  <pre>    L_0000: ldarg.0 
    L_0001: ldarg.1 
    L_0002: conv.ovf.i4 
    L_0003: conv.i 
    L_0004: stfld void* System.IntPtr::m_value
    L_0009: ret </pre>

<p>This confirmed it is indeed truncating the value (and doing an overflow check to boot). But wait, mscorlib.dll is a processor specific DLL so perhaps this is just a 32 bit OS thing.&#160; I switched over to a 64 bit machine, fired up Reflctor and found to my dismay that it had the exact same code.&#160; </p>

<p>After a few minutes I thought to open up task manager and to my surprise reflector was running in a WoW64 bit process.&#160; This meant it was still loading up the 32 bit version of mscorlib.dll.&#160; Next I fired up ildasm, loaded up a 64 bit mscorlib and confirmed that the code will not truncate on 64 bit machines. </p>

<pre>  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  conv.u
  IL_0003:  stfld      void* System.IntPtr::m_value
  IL_0008:  ret</pre>

<p>The conv.u code is a conversion to unsigned native platform int. On a 64 bit machine this will be an unsigned 8 byte number(see <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.conv_u.aspx">OpCodes.Conv_U</a> for more details).&#160; </p>

<p>So what does this mean for the developer.&#160; Essentially IntPtr(long) will do the right thing independently of the platform a developer is using.&#160; On a 32 bit platform it will (correctly) throw exceptions if a non-4GB address is passed in.&#160; In 64 bit land it will essentially do nothing and rely on the programmer to give correct addresses.&#160; </p></div>
    