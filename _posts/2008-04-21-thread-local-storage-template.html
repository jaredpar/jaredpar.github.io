<p>Thread local storage is another method of synchronization between threads.&nbsp; It is different that most synchronization cases because instead of sharing state between threads it enables developers to have independent, thread specific pieces of data which have a similar or common purpose.&nbsp; </p> <p>The uses of thread local storage (TLS) vary greatly but is a very powerful and lightweight method for storing data.&nbsp; TLS can easily be envisioned as a giant void* array for every thread.&nbsp; The entry point, TlsAlloc, provides an index into this array and allows the storage of arbitrary data [1].</p> <p>TLS is particularly useful for storing state information.&nbsp; For example, one of my components lives in a highly multi-threaded environment.&nbsp; Each thread serves essentially the same purpose and has the same states and state transition semantics.&nbsp; Like any good paranoid programmer I wanted to add contracts to check my state transitions and semantics.&nbsp; </p> <blockquote> <p>Contract.VerifyState(ExpectedState, ???CurrentState)</p></blockquote> <p>The question is where to store the state information for a thread?&nbsp; A global state variable won't suffice because there are N threads.&nbsp; A global array of state information also has it's share of problems: synchronization, determining an index, lifetime. </p> <p>TLS is ideally suited to this scenario.&nbsp; Each thread has an independent but similar concept of state.&nbsp; In my initialization code I allocate an TLS index and now I have a place to store my state.&nbsp; </p> <blockquote> <p>Contract.VerifyState(ExpectedState, *TlsGetValue(g_stateTlsIndex)</p></blockquote> <p>The next question is how to manage the lifetime?&nbsp; TLS provides a void* and the caller must manage the lifetime of the allocated memory.&nbsp;&nbsp; Since this is thread specific the ideal place is to manage the memory in the thread startup proc.&nbsp; However I don't own the creation of the thread, my component is called on a number of threads so this won't work.&nbsp; </p> <p>The solution is to use the stack.&nbsp; The initial return for TlsGetValue is NULL.&nbsp; If this situation is detected then the current stack frame is set to own the memory for the slot.&nbsp; Further accesses to the value do not own the memory and simply access it.&nbsp; The semantics are straight forward but annoying to constantly rewrite, so naturally write a template :)</p><pre class="code">    <span style="color: rgb(0,0,255)">template</span> &lt;<span style="color: rgb(0,0,255)">typename</span> T&gt;
    <span style="color: rgb(0,0,255)">class</span> TlsValue
    {
    <span style="color: rgb(0,0,255)">public</span>:
        TlsValue(DWORD index, <span style="color: rgb(0,0,255)">const</span> T&amp; defaultValue=T()) :
            m_pValue(NULL),
            m_index(index),
            m_owns(<span style="color: rgb(0,0,255)">false</span>)
        {
            m_pValue = <span style="color: rgb(0,0,255)">reinterpret_cast</span>&lt;T*&gt;(::TlsGetValue(m_index));
            <span style="color: rgb(0,0,255)">if</span> ( !m_pValue )
            {
                m_pValue = <span style="color: rgb(0,0,255)">new</span> T(defaultValue);
                m_owns = <span style="color: rgb(0,0,255)">true</span>;
                ::TlsSetValue(m_index, m_pValue);
            }
        }
        ~TlsValue()
        {
            <span style="color: rgb(0,0,255)">if</span> ( m_owns )
            {
                ::TlsSetValue(m_index, NULL);
                <span style="color: rgb(0,0,255)">delete</span> m_pValue;
            }
        }

        T* Value() <span style="color: rgb(0,0,255)">const
</span>        {
            <span style="color: rgb(0,0,255)">return</span> m_pValue;
        }

    <span style="color: rgb(0,0,255)">private</span>:
        <span style="color: rgb(0,128,0)">// Do not auto generate
</span>        TlsValue();
        TlsValue(<span style="color: rgb(0,0,255)">const</span> TlsValue&lt;T&gt;&amp;);
        TlsValue&amp; <span style="color: rgb(0,0,255)">operator</span>=(<span style="color: rgb(0,0,255)">const</span> TlsValue&lt;T&gt;&amp;);

        T* m_pValue;
        DWORD m_index;
        <span style="color: rgb(0,0,255)">bool</span> m_owns;
    };
</pre>
<p><a href="http://11011.net/software/vspaste"></a>&nbsp;</p>
<p>In addition to this blog post, I added a working sample to <a title="http://code.msdn.microsoft.com/TlsValue" href="http://code.msdn.microsoft.com/TlsValue">http://code.msdn.microsoft.com/TlsValue</a>.&nbsp; This is my first attempt at posting a sample on <a href="http://code.msdn.com">http://code.msdn.com</a> so please provide any and all feedback on the data.</p>
<p>[1] This is similar to data marked with the <a href="http://msdn2.microsoft.com/en-us/library/system.threadstaticattribute(VS.71).aspx">ThreadStatic attribute</a> in managed code without all of the slot messiness and with the added benefit of strong typing.</p></div>
    