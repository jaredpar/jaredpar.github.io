<p>Recently I ran into a situation where I needed to handle some events in F# in a special way.&#160; In this particular case I wanted to be able to disable and re-enable my handler based on changes in the program.&#160; Essentially the C# equivalent of continually adding and removing the handlers.&#160; </p>  <p>I started by using the F# Observable pattern.&#160; Disposing of the handler when I was through with it and recreating it on demand.&#160; This works great but after several uses I decided to write a full abstraction for it.&#160;&#160; For lack of a better name I call it ToggleHandler.&#160; </p>  <pre class="code">[&lt;AbstractClass&gt;]
<span style="color: blue">type internal </span>ToggleHandler() =
    <span style="color: blue">abstract </span>IsHandling : bool
    <span style="color: blue">abstract </span>Add : unit <span style="color: blue">-&gt; </span>unit
    <span style="color: blue">abstract </span>Remove : unit <span style="color: blue">-&gt; </span>unit
   
    <span style="color: blue">static member </span>Create&lt;'T&gt; (source:System.IObservable&lt;'T&gt;) (func: 'T <span style="color: blue">-&gt; </span>unit) = ToggleHandler&lt;'T&gt;(source,func)
    <span style="color: blue">static member </span>Empty = 
        { <span style="color: blue">new </span>ToggleHandler() <span style="color: blue">with 
            member </span>x.Add() = ()
            <span style="color: blue">member </span>x.Remove() = () 
            <span style="color: blue">member </span>x.IsHandling = <span style="color: blue">false </span>}

<span style="color: blue">and internal </span>ToggleHandler&lt;'T&gt; 
    ( 
        _source : System.IObservable&lt;'T&gt;,
        _func : 'T <span style="color: blue">-&gt; </span>unit) =  
    <span style="color: blue">inherit </span>ToggleHandler()
    <span style="color: blue">let mutable </span>_handler : System.IDisposable option = None
    <span style="color: blue">override </span>x.IsHandling = Option.isSome _handler
    <span style="color: blue">override </span>x.Add() = 
        <span style="color: blue">match </span>_handler <span style="color: blue">with
        </span>| Some(_) <span style="color: blue">-&gt; </span>failwith <span style="color: maroon">&quot;Already subcribed&quot;
        </span>| None <span style="color: blue">-&gt; </span>_handler &lt;- _source |&gt; Observable.subscribe _func |&gt; Option.Some
    <span style="color: blue">override </span>x.Remove() =
        <span style="color: blue">match </span>_handler <span style="color: blue">with
        </span>| Some(actual) <span style="color: blue">-&gt; 
            </span>actual.Dispose()
            _handler &lt;- None
        | None <span style="color: blue">-&gt; </span>()</pre>

<p>The design goal was to support my standard pattern for consuming events.&#160; Typically I store all event handlers as let bindings within a type but the actual delegate handling the event is bound to a member.&#160; Member declarations are not available in let bindings so creating an event handler becomes a 2 step process: defining in the let binding and then actually creating inside of a do binding. ToggleHandler facilitates this by providing a very easy let binding story. </p>

<pre class="code"><span style="color: blue">let mutable </span>_clickHandler = ToggleHandler.Empty</pre>

<p>The base class ToggleHandler is type independent so this will work for any event type.&#160; Creating the real binding inside of the initial do binding is likewise as easy (and lacking explicit types).&#160; </p>

<pre class="code"><span style="color: blue">do
    </span>_clickHandler &lt;- ToggleHandler.Create _button.Click this.OnButtonClick
    _clickHandler.Add()</pre>

<p>Now I can toggle my event handler at any point in the application by calling Add/Remove.&#160; </p>

<p>&#160;</p>

<p>Full Sample:</p>

<pre class="code"><span style="color: blue">type </span>Form1() <span style="color: blue">as </span>this =
    <span style="color: blue">inherit </span>Form()

    <span style="color: blue">let </span>_button = <span style="color: blue">new </span>Button()
    <span style="color: blue">let mutable </span>_clickHandler = ToggleHandler.Empty

    <span style="color: blue">do
        </span>_clickHandler &lt;- ToggleHandler.Create _button.Click this.OnButtonClick
        _clickHandler.Add()

    <span style="color: blue">member private </span>x.OnButtonClick (e:System.EventArgs) = 
        <span style="color: green">// Handle Click 
        </span>()

    <span style="color: blue">member private </span>x.ToggleHandler() =  
        <span style="color: blue">if </span>_clickHandler.IsHandling <span style="color: blue">then </span>_clickHandler.Remove()
        <span style="color: blue">else </span>_clickHandler.Add()</pre>
<a href="http://11011.net/software/vspaste"></a></div>
    