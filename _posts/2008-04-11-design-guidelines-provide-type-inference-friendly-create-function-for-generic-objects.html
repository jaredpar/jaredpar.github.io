<p>Really this guideline is a bit longer but putting it all in a blog title seemed a bit too much.&#160; The full guideline should read: &quot;If a generic class constructor arguments contain types of all generic parameters, provide a static method named Create on a static class of the same class name as the generic class which takes the same arguments and calls the constructor.&quot;&#160; Quite a mouth full.&#160; </p>  <p>Lets look at a specific example with <a href="http://blogs.msdn.com/jaredpar/archive/2008/01/27/tuples-part-8-finishing-up.aspx">Tuples</a>.&#160; Tuples are generic with respect to the values they are representing.&#160; Without any type inference help we would have to write the following code to create a simple tuple. </p>  <pre class="code">            <span style="color: rgb(0,0,255)">var</span> tuple = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;<span style="color: rgb(0,0,255)">int</span>, <span style="color: rgb(0,0,255)">string</span>&gt;(5, <span style="color: rgb(163,21,21)">&quot;astring&quot;</span>);</pre>

<p>Not too bad because we are using simple types.&#160; But what happens when we are using really long type names?&#160; </p>

<pre class="code">            <span style="color: rgb(0,0,255)">var</span> tuple2 = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;<span style="color: rgb(0,0,255)">string</span>,<span style="color: rgb(43,145,175)">Dictionary</span>&lt;<span style="color: rgb(0,0,255)">string</span>, <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">int</span>&gt;&gt;&gt;(val1, val2);</pre>

<p>As we can see, the code is getting quite a bit uglier.&#160; This pattern is in fact not maintainable once we start using un-namable types such as anonymous types or generics of anonymous types.&#160; </p>

<p>The problem here is we are not leveraging the compilers type inference capabilities.&#160; The compiler can easily infer the types of a tuple argument and hence create a tuple.&#160; We just need to provide a mechanism to do so.&#160; The best way is to define a static method on a static class with the same name as the generic.&#160; Lets call this method Create.</p>

<pre class="code">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Tuple</span> {
        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;TA, TB&gt; Create&lt;TA, TB&gt;(TA valueA, TB valueB) { 
            <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;TA, TB&gt;(valueA, valueB); 
        }
    }</pre>

<p>The method Tuple.Create still has two generic parameters.&#160; However since we are providing a set of values which contain types for every generic parameter, the compiler can infer the generic arguments.&#160; Now we can create a Tuple without specifying any generic arguments.&#160; Because no types are specified this will work with any value in the code including un-namable types.&#160; </p>

<pre class="code">            <span style="color: rgb(0,0,255)">var</span> tuple = <span style="color: rgb(43,145,175)">Tuple</span>.Create(6, <span style="color: rgb(163,21,21)">&quot;astring&quot;</span>);
            <span style="color: rgb(0,0,255)">var</span> tuple2 = <span style="color: rgb(43,145,175)">Tuple</span>.Create(6, <span style="color: rgb(0,0,255)">new</span> { name = <span style="color: rgb(163,21,21)">&quot;aname&quot;</span>, value = 42 });</pre>
<a href="http://11011.net/software/vspaste"></a></div>
    