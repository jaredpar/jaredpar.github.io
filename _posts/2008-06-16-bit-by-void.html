<p>Recently I got bit by void* again because of another C++ quirk I didn't think through.&#160; I had a class which wrapped a void* which could be one of many different structs.&#160; The structs were POD and didn't have any shared functionality hence I didn't bother creating an inheritance hierarchy.&#160; Unfortunately I defined the structs like so</p>  <pre>class C1 {
  struct S1 {
    int field1;
    float field2;
  };
  struct S2 {
    char field1;
  };
  ~C1() {
    delete m_pData;
  }
  void* m_pData; // Can be S1,S2,etc ...
}</pre>

<p>Unfortunately this <strong>appeared </strong>to work fine for quite some time.&#160; Then after a couple of days of bug fixes I ended up with a memory leak which I quickly tracked down to a leaked COM object.&#160; Although C1 was at fault I didn't suspect any changes to this class because after all it was working fine for some time and all I did was add a new field to one of the structs.&#160; If the structs were being successfully free'd before a new field shouldn't change anything.</p>

<p>The field I added was of type CComPtr&lt;T&gt; which exposed a greater problem in my code.&#160; Even though I properly delete the pointer in C1::~C1() I wasn't running the destructor on the pointed at data and instead I was just freeing the memory.&#160; Until I added a field which had a non-trivial destructor this wasn't a problem (still a bug though).&#160; </p>

<p>Why did this happen?&#160; By deleting a void* and expecting a destructor to run what I'm really doing is asking C++ to behave polymorphicly.&#160; C++ as a rule won't behave this way unless it is specifically asked to with inheritance and virtual.&#160;&#160; In the case of void*, it just won't.&#160; The fix is to actually implement an inheritance hierarchy which supports polymorphism.</p>

<p>It's just another rule that I need to remember when coding C++.&#160; </p>

<blockquote>
  <p>Deleting void* is dangerous, period. </p>
</blockquote>

<p>Unfortunately C++ has too many of these rules and not enough enforcement.&#160; </p></div>
    