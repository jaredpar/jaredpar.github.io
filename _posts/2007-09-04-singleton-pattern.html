<P>Quite awhile back I posted about how to create a re-usable singleton pattern in .Net.&nbsp; Link is <A href="http://blogs.msdn.com/jaredpar/archive/2004/11/24/269133.aspx" mce_href="http://blogs.msdn.com/jaredpar/archive/2004/11/24/269133.aspx">here</A>.&nbsp; A bit of time has passed and I've altered the pattern a bit.&nbsp; The reasons for the change are some new type inference patterns and FxCop cleanliness.&nbsp; </P>
<P>The first pattern I introduced had a couple of FxCop violations.&nbsp; Namely Microsoft.Design CA1000 - Do not declare static members on generic types.&nbsp; The logic here being that static methods don't have any type inference benefits as you must explicitly add the type into the name of the type you were using (in this case Singleton).&nbsp; </P>
<P>Secondly because T was at a class level rather than a method level I couldn't have granualar methods which had differing set of constraints.&nbsp; The result was a pattern that was not always easy to write out.&nbsp; </P>
<P>The new pattern takes care of both of these problems.&nbsp; It has two methods.&nbsp; One of which can be satisfied with a trivial lambda expression.&nbsp; The other can easily be used for classes that satisfy the generic constraint new() with no additional lambda.</P><PRE class=code>    <SPAN style="COLOR: rgb(0,0,255)">class</SPAN> <SPAN style="COLOR: rgb(43,145,175)">c1
</SPAN>    {
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> <SPAN style="COLOR: rgb(43,145,175)">c1</SPAN> Instance1 
        {
            <SPAN style="COLOR: rgb(0,0,255)">get</SPAN> { <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Singleton</SPAN>.GetInstance(() =&gt; <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> <SPAN style="COLOR: rgb(43,145,175)">c1</SPAN>());}
        }

        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> <SPAN style="COLOR: rgb(43,145,175)">c1</SPAN> Instance2
        {
            <SPAN style="COLOR: rgb(0,0,255)">get</SPAN> { <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Singleton</SPAN>.GetInstance&lt;<SPAN style="COLOR: rgb(43,145,175)">c1</SPAN>&gt;(); }
        }

        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> c1()
        {

        }
        
    }</PRE>
<P><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>Below is the new singleton pattern.</P><PRE class=code><SPAN style="COLOR: rgb(0,0,255)">    public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">delegate</SPAN> T <SPAN style="COLOR: rgb(43,145,175)">Operation</SPAN>&lt;T&gt;();</PRE><A href="http://11011.net/software/vspaste"></A><PRE class=code>    <SPAN style="COLOR: rgb(128,128,128)">///</SPAN><SPAN style="COLOR: rgb(0,128,0)"> </SPAN><SPAN style="COLOR: rgb(128,128,128)">&lt;summary&gt;
</SPAN>    <SPAN style="COLOR: rgb(128,128,128)">///</SPAN><SPAN style="COLOR: rgb(0,128,0)"> Used for classes that are single instances per appdomain
</SPAN>    <SPAN style="COLOR: rgb(128,128,128)">///</SPAN><SPAN style="COLOR: rgb(0,128,0)"> </SPAN><SPAN style="COLOR: rgb(128,128,128)">&lt;/summary&gt;
</SPAN>    <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> <SPAN style="COLOR: rgb(0,0,255)">class</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Singleton
</SPAN>    {
        <SPAN style="COLOR: rgb(0,0,255)">private</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> <SPAN style="COLOR: rgb(0,0,255)">class</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;
        {
            <SPAN style="COLOR: rgb(0,0,255)">internal</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> T s_instance;
        }

        [<SPAN style="COLOR: rgb(43,145,175)">SuppressMessage</SPAN>(<SPAN style="COLOR: rgb(163,21,21)">"Microsoft.Reliability"</SPAN>, <SPAN style="COLOR: rgb(163,21,21)">"CA2002"</SPAN>)]
        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> T GetInstance&lt;T&gt;(<SPAN style="COLOR: rgb(43,145,175)">Operation</SPAN>&lt;T&gt; op)
        {
            <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (<SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;.s_instance == <SPAN style="COLOR: rgb(0,0,255)">null</SPAN>)
            {
                <SPAN style="COLOR: rgb(0,0,255)">lock</SPAN> (<SPAN style="COLOR: rgb(0,0,255)">typeof</SPAN>(<SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;))
                {
                    <SPAN style="COLOR: rgb(0,0,255)">if</SPAN> (<SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;.s_instance == <SPAN style="COLOR: rgb(0,0,255)">null</SPAN>)
                    {
                        T temp = op();
                        System.Threading.<SPAN style="COLOR: rgb(43,145,175)">Thread</SPAN>.MemoryBarrier();
                        <SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;.s_instance = temp;
                    }
                }
            }
            <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> <SPAN style="COLOR: rgb(43,145,175)">Storage</SPAN>&lt;T&gt;.s_instance;
        }

        <SPAN style="COLOR: rgb(0,0,255)">public</SPAN> <SPAN style="COLOR: rgb(0,0,255)">static</SPAN> T GetInstance&lt;T&gt;()
            <SPAN style="COLOR: rgb(0,0,255)">where</SPAN> T : <SPAN style="COLOR: rgb(0,0,255)">new</SPAN>()
        {
            <SPAN style="COLOR: rgb(0,0,255)">return</SPAN> GetInstance(() =&gt; <SPAN style="COLOR: rgb(0,0,255)">new</SPAN> T());
        }
    }

<SPAN style="COLOR: rgb(0,0,255)">    #endregion
</SPAN>}
</PRE>
<P>Edit: Originally forgot to add the signature for Operation&lt;T&gt;</P></div>
    