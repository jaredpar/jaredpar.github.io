<P>Writing a proper serialization mechanism is ofter very difficult.&nbsp; The problem is most people don't realize this because it just works in their application and .Net makes it very easy to do.&nbsp; A lot of the problem is not understanding what factors you need to consider when writing a serializer.</P>
<P>Failures with serialization can be classified in two ways</P>
<OL>
<LI>Critical - Deserialization is impossible.&nbsp; Typically resulting in a runtime exception or fata error</LI>
<LI>Incorrect - Deserialization succeeds but the underlying data is incorrect in some fashion</LI></OL>
<P>For this post I use the term "box" describes a place where all the factors which can interfere with proper serialization differ.&nbsp; Below is a list of all of the factors I know of that can affect serialization.&nbsp; And by affect I mean that serializing data in one "box" and deserializing it in another "box" could have an affect on the data.</P>
<OL>
<LI>Process - There are types of data which are only valid within the process where they are created.&nbsp; For instance when you open a file in Windows, you are given a handle.&nbsp; The handle is only valid for the process where the file was opened, passing it to another process by value will cause an error in the target process.&nbsp; Or worse the handle will be valid in the target process but will not point to the same file.&nbsp; </LI>
<LI>Computers - This&nbsp;problem is a superset of the process problem.&nbsp; In addition to the problems of a process you have to deal with setup.&nbsp; For instance binary serialization&nbsp;in .Net takes an inherit dependency on assemblies at a specific version[1].&nbsp; If the target computer does not have these assemblies then deserialization will fail.</LI>
<LI>TimeZone / Where - If you embed time in your data as a string and serialize/deserialize in different time zones you will encounter an "Incorrect" deserialization failure.</LI>
<LI>Thread - There are particular types of data that are only valid within a specific thread (thread local storage, COM pointers).&nbsp; Depending on the type of data it can cause varying failures in an application.&nbsp; One good example of this are COM pointers.&nbsp; COM has strict marshalling rules with respect to threads[2].&nbsp; Passing a COM interface pointer between threads without calling into appropriate API (CoMarshalInterThreadInterfaceInStream , CoGetInterfaceAndReleaseStream).&nbsp; </LI>
<LI>Application Domain - Application Domains in .Net are essentially mini-processes.&nbsp; While it's probably valid to pass a file handle between application domains, it's not always valid to pass managed protected resources between two domains.&nbsp; Every application domain in a .Net process can have different security permissions and hence it's possible to pass references to in-accessible resources to other application domains.</LI>
<LI>BigEndian / Little Endian - If you're doing custom serialization to bytes you also need to be concerned with the endian-ness of the machine you're working on.&nbsp; It's possible (albeit hard) to get into this problem and most people won't ever have to deal with it for a managed application.&nbsp; I don't know of a good way to hit this in managed code but it's definately a problem for cross platform application and unmanaged code.</LI></OL>
<P>Most of the problems I've seen with respect to serialization is because&nbsp;people embed a "box" sensitive resource in their serialization data but don't realize it.&nbsp; When desigining serialization for&nbsp;your data you need&nbsp;to consider all of the factors above which affect your application.&nbsp; </P>
<P>The good&nbsp;news is&nbsp;most applications don't have to consider all of the&nbsp;above factors into their application.&nbsp; Below is a breakdown of some common category applications&nbsp;and the list of factors they have to consider.&nbsp;</P>
<OL>
<LI>MyApp Serializers - The data is serialized for&nbsp;my application and my application&nbsp;only.&nbsp;&nbsp;It's a hobby app or a small office app.&nbsp;These are the easiest because they usually only have to take into account factor #1.&nbsp; They don't care about application domains, computer-&gt;computer communication and the like.&nbsp; They have some data they'd merely like to preserve between sessions in a file somewhere for this particular user.</LI>
<LI>Product Serializer - The is a for sale global product and reliability is key.&nbsp; But once again the data is only serialized by and for my application.&nbsp;&nbsp;They&nbsp;are a bit harder because they are expected to work in more situations.&nbsp; They may have to consider a wider range of scenarios&nbsp;including threads and application domains.&nbsp;</LI>
<LI>Cooperative App - This app serializes data for use in other "boxes".&nbsp; These are the hardest to write because they often have to </LI></OL>
<P>[1] There are ways to relax these dependencies but at the end of the day some version of the assembly must be on the machine.</P>
<P>[2] Lookup COM Apartments for more information.</P><div style="clear:both;"></div></div>
    