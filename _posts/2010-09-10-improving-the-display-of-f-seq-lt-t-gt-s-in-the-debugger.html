<p>F#’s seq&lt;T&gt; expressions are a frustrating item to inspect at debug time.&#160; A seq&lt;T&gt; value is a collection and when users inspect such a value at debug time they want to see the contents of the collection.&#160; Instead they are often presented with a view resembling the following</p>  <p><a href="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/2570.seq1_5F00_015376E1.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="seq1" border="0" alt="seq1" src="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/5810.seq1_5F00_thumb_5F00_47D066E9.png" width="754" height="173" /></a></p>  <p>The reason this happens is a consequence of how the debugger works.&#160; When a value is expanded it essentially enumerates the members and display the values as child nodes.&#160; This is great for most types of objects where the members hold the mots interesting data.&#160; For collections though it’s often far more interesting to see the elements in the collection.&#160; </p>  <p>Most collection types don’t have this issue because they are either custom handled by the expression evaluator, arrays for example, or use a debugger type proxy helper class (Dictionary&lt;TKey,TValue&gt;, List&lt;T&gt;, etc …).&#160;&#160; One class of collections that do not display well are C# iterators and F# seq expressions.&#160; Both languages translate these into generated types which expose IEnumerable&lt;T&gt;.&#160; The type contains no custom type proxy helper classes and expression evaluators don’t custom handle them.&#160; Users cannot fix the problem either by adding a custom DebuggerTypeProxy because they are generated types and hence not directly accessible to the user.&#160; </p>  <p>The languages team realized this was a problem and added a debugger feature in Visual Studio 2008 to help: the “Results View” node.&#160; When an expression appears in the locals or watch window which is typed to IEnumerable&lt;T&gt; and has no associated DebuggerTypeProxy the expression evaluator will add a special child named Results View.&#160; When this is expanded it will enumerate the IEnumerable and display the values.&#160; Here is the equivalent C# sequence displayed in 2008 and beyond.</p>  <p><a href="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/2021.seq2_5F00_476433F4.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="seq2" border="0" alt="seq2" src="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/0458.seq2_5F00_thumb_5F00_46F800FF.png" width="754" height="248" /></a></p>  <p>This display is much better because it’s actually showing me the elements in the IEnumerable&lt;T&gt;!!!</p>  <p>Astute readers may be wondering at this point why this doesn’t work for F# out of the box.&#160; After all F#’s seq&lt;T&gt; maps to IEnumerable&lt;T&gt; and the F# debugging experience uses the C# expression evaluator.&#160; So there should be no difference in the experience here.All of this is true, there’s just one small problem.&#160; The C# (and VB) expression evaluators don’t actually do the work of enumerating the IEnumerable&lt;T&gt;.&#160; Instead they rely on a helper class defined in System.Core.dll.&#160; If this DLL is not loaded then the Results View node can’t be created.&#160; The C# and VB.Net project system work to have System.Core, and other important DLL’s, loaded at the start of a debugging session.&#160; The F# project system does not do this and hence misses out on this experience by default.</p>  <p>Developers can get this experience in F# by forcing System.Core.dll into the debugee process.&#160; My favorite trick is to add the following line at the start of my F# applications.</p>  <pre class="code"><span style="color: blue">#if </span>DEBUG
System.Linq.Enumerable.Count([]) |&gt; ignore
<span style="color: blue">#endif

</span></pre>

<p>This forces System.Core.dll into the process in debug builds which results in a much nicer display for any seq&lt;T&gt; expressions I have.&#160; </p>

<p><a href="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/3755.seq3_5F00_663AA7D2.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="seq3" border="0" alt="seq3" src="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-00-39-97-metablogapi/5226.seq3_5F00_thumb_5F00_05E9819B.png" width="754" height="242" /></a></p>

<p>When I originally posted this solution to a <a href="http://stackoverflow.com/q/3512266/23283">question</a> on StackOverflow, <a href="http://stackoverflow.com/users/32133/tim-robinson">Tim Robinson</a> pointed out that it’s possible to force System.Core.dll into the debugee process without adding extra debug code to the process.&#160; Simply use the Assembly.Load API to do it by evaluating the following expression in the watch window. </p>

<blockquote>
  <p>System.Reflection.Assembly.Load(&quot;System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL&quot;</p>
</blockquote>

<p>I still prefer my solution but this is a great trick to have if developers are in a situation where they can’t edit the code.&#160; Such as debugging in a production environment.&#160; </p><div style="clear:both;"></div></div>
    