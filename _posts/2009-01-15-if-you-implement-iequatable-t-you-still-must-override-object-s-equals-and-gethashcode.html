<p>CLR 2.0 introduced <a href="http://msdn.microsoft.com/en-us/library/ms131187.aspx">IEquatable&lt;T&gt;</a> which is an interface that allows for type safe equality comparisons.&#160; Previously, the best available method for comparing equality was the virtual <a href="http://msdn.microsoft.com/en-us/library/system.object.equals.aspx">Object Equals</a> method.&#160; The method is loosely typed since it takes an object as a parameter.&#160; This is easy enough to deal with on the client with a simple cast to the appropriate type.</p>  <pre class="code"><span style="color: blue">class </span><span style="color: #2b91af">Student </span>{
    <span style="color: blue">public override bool </span>Equals(<span style="color: blue">object </span>obj) {
        <span style="color: blue">var </span>other = obj <span style="color: blue">as </span><span style="color: #2b91af">Student</span>;
        <span style="color: blue">if </span>(other == <span style="color: blue">null</span>) {
            <span style="color: blue">return false</span>;
        }
        <span style="color: green">// rest of comparison
    </span>}
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>IEquatable&lt;T&gt; is a significant improvement over this pattern because it provides a strongly typed equals method.&#160; This protects both the caller and callee from passing incompatible object types.&#160; Additionally it avoids the overhead of boxing for value types.</p>

<p>These benefits are nice but if you implement IEquatable&lt;T&gt; you still must override Equals(object) and GetHashCode.&#160; Not doing so is wrong and <strong>will</strong> cause you pain down the road.&#160; I’ve explored this <a href="http://blogs.msdn.com/jaredpar/archive/2008/05/09/iequatable-of-t-and-gethashcode.aspx">topic</a> briefly in the past but wanted to expand on it a bit with some concrete examples. </p>

<p>Before we get into the technical details of why, lets look at this from an expectation point of view.&#160; Implementing IEquatable&lt;T&gt; is a statement that “this object knows what it means to be equal.”&#160; This in effect adds a contract to your class declaring that it knows how to be compared for equality.&#160; Your object should live up to these expectations in order to avoid confusing other programmers who aren’t intimately familiar with your class.&#160; Confusing programmers is rarely a good idea.&#160; </p>

<p><strong>Issue #1: IEqualityComparer&lt;T&gt; requires GetHashCode()</strong></p>

<p>Strongly typed collections such as Dictionary&lt;TKey,TValue&gt; and HashSet&lt;T&gt; must be able to compare objects for equality in order to function.&#160; Starting in 2.0, the BCL provides an interface by which object equality semantics can be performed: IEqualityComparer&lt;T&gt;.&#160; This class is used in many other places besides collections, but inspecting the collection classes is the easiest way to get a feel for it’s use.</p>

<p>Lets take a look at the definition of IEqualityComparer&lt;T&gt;</p>

<pre class="code"><span style="color: blue">public interface </span><span style="color: #2b91af">IEqualityComparer</span>&lt;T&gt; {
    <span style="color: blue">bool </span>Equals(T x, T y);
    <span style="color: blue">int </span>GetHashCode(T obj);
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>The default definition is an internal class in the BCL named GenericEqualityComparer&lt;T&gt;. The default implementation of IEqualityComparer&lt;T&gt; relies on IEquatable&lt;T&gt; for it’s implementation.&#160; </p>

<p>But if it uses IEquatable&lt;T&gt; for it’s implementation how can it possible implement GetHashCode()?&#160; Simple, it uses Object.GetHashCode().&#160; This means an object must implement IEquatable&lt;T&gt; and GetHashCode() in order to function correctly in places where IEqualityComparer&lt;T&gt; is used.</p>

<p>But wait, I don’t actually implement IEqualityComparer&lt;T&gt; anywhere so I’m safe right?&#160; Unfortunately no.&#160; Very few people actually implement IEqualityComparer&lt;T&gt;.&#160; Instead they use EqualityComparere&lt;T&gt;.Default to access a given IEqualityComparer&lt;T&gt; for a given type T.&#160; </p>

<p>In fact, the standard pattern for methods which take an IEqualityComparer&lt;T&gt; is to have an overload that doesn’t and pass EqualityComparer&lt;T&gt;.Default to the one that does.</p>

<pre class="code"><span style="color: blue">public static class </span><span style="color: #2b91af">Example </span>{
    <span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;T&gt; Distinct&lt;T&gt;(<span style="color: blue">this </span><span style="color: #2b91af">IEnumerable</span>&lt;T&gt; source) {
        <span style="color: blue">return </span>Distinct(source, <span style="color: #2b91af">EqualityComparer</span>&lt;T&gt;.Default);
    }
    <span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;T&gt; Distinct&lt;T&gt;(
        <span style="color: blue">this </span><span style="color: #2b91af">IEnumerable</span>&lt;T&gt; source, 
        <span style="color: #2b91af">IEqualityComparer</span>&lt;T&gt; comparer) {
        <span style="color: green">// implementation
    </span>}
}</pre>
<a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a>

<p>If your object implements IEquatable&lt;T&gt; this will eventually cause it to create an instance of GenericEqualityComparer&lt;T&gt; and hence a reliance on GetHashCode.</p>

<p><strong>Issue #2: Non-Strongly typed collections and Frameworks don’t use IEquatable&lt;T&gt;</strong></p>

<p>IEquatable&lt;T&gt; only provides equality comparisons in strongly typed scenarios.&#160; It is not convenient to access this interface in less strongly typed scenarios.&#160; Consider for instance the original 1.0 collection classes: ArrayList, Hashtable, etc …&#160; These are all object based collections and have no way in which to cast to IEquatable&lt;T&gt;.&#160; Instead these collections must rely on the Object based methods of Equality.&#160; </p>

<p>Without implementing Object.Equals and Object.GetHashCode your type will not actually do any sort of comparison.&#160; This will cause lots of incorrect behavior for programmers who expect the class to understand equality.&#160; </p>

<pre class="code"><span style="color: blue">class </span><span style="color: #2b91af">Person </span>: <span style="color: #2b91af">IEquatable</span>&lt;<span style="color: #2b91af">Person</span>&gt; {
    <span style="color: blue">public readonly string </span>Name;
    <span style="color: blue">public </span>Person(<span style="color: blue">string </span>name) {
        Name = name;
    }
    <span style="color: blue">public bool </span>Equals(<span style="color: #2b91af">Person </span>other) {
        <span style="color: blue">if </span>(other == <span style="color: blue">null</span>) {
            <span style="color: blue">return false</span>;
        }
        <span style="color: blue">return </span><span style="color: #2b91af">StringComparer</span>.Ordinal.Equals(Name, other.Name);
    }
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<pre class="code"><span style="color: blue">static void </span>EqualityCheck() {
    <span style="color: blue">var </span>p = <span style="color: blue">new </span><span style="color: #2b91af">Person</span>(<span style="color: #a31515">&quot;Bob&quot;</span>);
    <span style="color: blue">var </span>list = <span style="color: blue">new </span><span style="color: #2b91af">ArrayList</span>();
    list.Add(p);
    <span style="color: #2b91af">Console</span>.WriteLine(list.Contains(p)); <span style="color: green">// Prints: True
    </span><span style="color: #2b91af">Console</span>.WriteLine(list.Contains(<span style="color: blue">new </span><span style="color: #2b91af">Person</span>(<span style="color: #a31515">&quot;Bob&quot;</span>)));    <span style="color: green">// Prints: False
</span>}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>This goes against expectation.&#160; Both Person instances in this case are equal by definition of Person yet Contains fails.&#160; Implementing Object.Equals and Object.GetHashCode will remove this confusion.</p>

<p>The list of frameworks which still use loosely typed collections include WinForms, WPF, WebForms, etc …&#160; It’s almost inevitable that you will end up using a loosely typed collection in your project somewhere.&#160; </p>

<p><strong>Isssue #3: Equality and hash codes are linked in the BCL</strong></p>

<p>Rightly or wrongly, equality and hash codes are unbreakably linked in the BCL.&#160; If an object can be compared for equality it also must be able to produce a hashcode.&#160;&#160; This implicit contract exists many places throughout the framework.&#160; </p>

<p>As previously displayed, implementing Object.Equals() after implementing IEquatable&lt;T&gt; is straight forward and boiler plate code.&#160; Object.GetHashCode can be a bit trickier because there are many <a href="http://blogs.msdn.com/jaredpar/archive/2008/04/28/properly-implementing-equality-in-vb.aspx">implicit contracts</a> for GetHashCode.&#160; Often mutable objects cannot provide an efficient hashing mechanism.&#160; In that case just <a href="http://blogs.msdn.com/jaredpar/archive/2008/06/03/making-equality-easier.aspx">return 1</a>.&#160; This will satisfy all of the implicit contracts around GetHashCode() and takes little time to do.&#160; Yes, it will cause a Dictionary to effectively be a linked list.&#160; But that’s a heck of a lot better than simply not working at all.&#160; </p></div>
    