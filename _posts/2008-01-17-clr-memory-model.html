<p>Internally and externally I see a lot of questions about the .Net Memory Model.&nbsp; I think a lot of the confusion comes from the specs.&nbsp; Mainly that there are really two of them.</p> <p>The first is the <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-335.pdf">ECMA CLI Memory Model</a> (Partition 1, Section 12).&nbsp; This standard introduces a relaxed memory model which, IMHO, makes multi-threading program a bit difficult.&nbsp; For instance it allows for write reordering which can be quite confusing to programmers (and result in very hard to track bugs). </p> <p>The CLR 2.0 Memory Model is a stricter version of the EMCA model.&nbsp; There are two excellent sources of information on the more strict version.</p> <ul> <li><a title="http://msdn.microsoft.com/msdnmag/issues/05/10/MemoryModels/" href="http://msdn.microsoft.com/msdnmag/issues/05/10/MemoryModels/">http://msdn.microsoft.com/msdnmag/issues/05/10/MemoryModels/</a>&nbsp; - Vance Morrison's detailed article on multi-threaded apps and locking techniques.&nbsp; He goes into a bit of detail on how the ECMA and CLR 2.0 models differ and the justification for making them do so.&nbsp; </li> <li><a title="http://www.bluebytesoftware.com/blog/2007/11/10/CLR20MemoryModel.aspx" href="http://www.bluebytesoftware.com/blog/2007/11/10/CLR20MemoryModel.aspx">http://www.bluebytesoftware.com/blog/2007/11/10/CLR20MemoryModel.aspx</a> - Joe Duffy sums up Vance's article and defines a set of 6 simple rules to the memory model.&nbsp; </li></ul> <p>For anyone doing multi-threaded programming in .Net, both of these articles are a must read.&nbsp; </p></div>
    