<p>For previous articles in this series please see  <ul> <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/04/27/closures-in-vb-part-1.aspx">Part 1: Introduction</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/05/03/closures-in-vb-part-2-method-calls.aspx">Part 2: Method Calls</a>  <li><a href="http://blogs.msdn.com/jaredpar/archive/2007/05/25/closures-in-vb-part-3-scope.aspx">Part 3: Scope</a></li></ul> <p>Sorry for the long delay between posts here.&nbsp; We're getting Orcas out the door and getting this series completed takes a back door to shipping.&nbsp; </p> <p>Originally I wanted to talk about looping structures next.&nbsp; However when I started writing that post I realized that I had to talk about lifetime before the looping structures would make sense.&nbsp; </p> <p>Prior to Orcas the lifetime of a variable in VB was the entire function.&nbsp; This presented several problems from a closures perspective.&nbsp; Imagine you had a looping structure and the value was used in a lambda expression.&nbsp; </p><pre>    <span style="color: blue">Sub</span> LifetimeExample()
        <span style="color: blue">Dim</span> list <span style="color: blue">As</span> <span style="color: blue">New</span> List(Of Func(Of <span style="color: blue">Integer</span>))
        <span style="color: blue">For</span> i = <span style="color: maroon">0</span> <span style="color: blue">To</span> <span style="color: maroon">5</span>

            <span style="color: blue">Dim</span> x = i * <span style="color: maroon">2</span>
            <span style="color: blue">If</span> <span style="color: maroon">True</span> <span style="color: blue">Then</span>
                list.Add(<span style="color: blue">Function</span>() x)
            <span style="color: blue">End</span> <span style="color: blue">If</span>
        <span style="color: blue">Next</span>

        <span style="color: blue">For</span> <span style="color: blue">Each</span> f <span style="color: blue">In</span> list
            Console.Write(f() &amp; " ")
        <span style="color: blue">Next</span>
    <span style="color: blue">End</span> <span style="color: blue">Sub</span></pre>
<p>In this example if we left the lifetime rules unchanged, there would be a single variable "x" for the entire function.&nbsp; That means that we would end up printing out </p>
<p>10 10 10 10 10</p>
<p>This is somewhat unexpected and essentially means that VB could not support complex Lambda scenarios.&nbsp; To fix this we altered the lifetime of variables to be tied to the scope they were contained in.&nbsp; The end effect is that each iteration of the loop has a separate "x" since each iteration enters and leaves the scope of the "if" statement.&nbsp; As a result it will print out </p>
<p>0 2 4 6 8 10</p>
<p>We did make one backcompat adjustment for this change.&nbsp; The lifetime of variables in VB was visible if you tried to use an uninitialized variable in a loop/goto.&nbsp; For instance the following code will also print out 0 2 4 6 8 10 because it takes advantage of the fact that the variable "x" has a lifetime longer than the loop.</p><pre>    <span style="color: blue">Sub</span> VisibleLifetime()
        <span style="color: blue">For</span> i = <span style="color: maroon">0</span> <span style="color: blue">To</span> <span style="color: maroon">5</span>
            <span style="color: blue">Dim</span> x <span style="color: blue">As</span> <span style="color: blue">Integer</span>
            Console.WriteLine(x)
            x += <span style="color: maroon">2</span>
        <span style="color: blue">Next</span>
    <span style="color: blue">End</span> <span style="color: blue">Sub</span></pre>
<p>To make sure that we didn't break any existing code we had one little errata for the change.&nbsp; When a variable's scope is re-entered, and hence recreated, and it is not initialized to a value it will get the last value of the variable.&nbsp; </p></div>
    