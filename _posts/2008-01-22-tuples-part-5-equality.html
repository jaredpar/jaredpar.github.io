<p><a href="http://blogs.msdn.com/jaredpar/archive/2008/01/10/tuples-part-4-interface.aspx">Part 4</a> left us with a reusable, abstract and inference friendly Tuple class.&#160; The next step is to be able to test for Tuple equality.&#160; </p>  <p>For the Tuple implementation, two tuples will be defined as equal if all of their members are equal.&#160; Seems fairly straight forward.&#160; The trick is in the implementation.&#160; In addition to doing the typical override of Equals/GetHashCode the Tuple implementation will be implementing <a href="http://msdn2.microsoft.com/en-us/library/ms131187.aspx">IEquatable&lt;T&gt;</a> and overloading the standard equality operators.</p>  <p>Tuple members are all unconstrained generic classes which leaves us with a non-great starting point.&#160; </p>  <p>For instance what if we are dealing with value types?&#160; Is Equals() the best method to call?&#160; What if the type in question implements <a href="http://msdn2.microsoft.com/en-us/library/ms131187.aspx">IEquatable&lt;T&gt;</a> or has a well known <a href="http://msdn2.microsoft.com/en-us/library/ms132151.aspx">IEqualityComparer&lt;T&gt;</a>?&#160;&#160; What if one or both of the arguments are reference types and null? What if they're value types and equal to null?</p>  <p>Luckily there is an easy and straight forward solution.&#160; The BCL defines a class, <a href="http://msdn2.microsoft.com/en-us/library/ms132123.aspx">EqualityComparer&lt;T&gt;</a>, which will properly perform equality comparisons for objects of a particular type.&#160; This makes the Equals override very straight forward. </p>  <p>There is one small trick to implementing Equals correctly.&#160; The implementation explicitly uses Object.ReferenceEquals to check for null rather than ==.&#160; The reason being is once operator== is defined for the type Tuple, comparison for even null will bind to this operator.&#160; Part of checking for operator== will end up calling Equals and hence you can end in a stack overflow fairly quick.&#160; Note that our implementation of == will work around this but it's still safer to be explicit.&#160; </p>  <p>function script:Gen-Equals   <br />{    <br />&#160;&#160;&#160; param ( [int] $count = $(throw &quot;Need a count&quot;) )    <br />&#160;&#160;&#160; $OFS = ','    <br />&#160;&#160;&#160; $gen = &quot;&lt;&quot; + [string](0..($count-1) | %{ &quot;T&quot;+$upperList[$_] }) + &quot;&gt;&quot;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; &quot;public override bool Equals(object obj) { &quot;    <br />&#160;&#160;&#160; &quot;return Equals(obj as Tuple$gen); }&quot;    <br />&#160;&#160;&#160; &quot;public bool Equals(Tuple$gen other) {&quot;    <br />&#160;&#160;&#160; &quot;if ( Object.ReferenceEquals(other,null) ) { return false; }&quot;    <br />&#160;&#160;&#160; &quot;if (&quot;     <br />&#160;&#160;&#160; $OFS = &quot;&amp;&amp;&quot;    <br />&#160;&#160;&#160; [string](0..($count-1) | %{&quot;EqualityComparer&lt;T{0}&gt;.Default.Equals(m_{1},other.m_{1})&quot; -f $upperList[$_],$lowerList[$_] })    <br />&#160;&#160;&#160; &quot;) { return true; }&quot;    <br />&#160;&#160;&#160; &quot;return false;&quot;     <br />&#160;&#160;&#160; &quot;}&quot;    <br />}</p>  <p>GetHashCode can also utilize <a href="http://msdn2.microsoft.com/en-us/library/ms132123.aspx">EqualityComparer&lt;T&gt;</a>.</p>  <p>function script:Gen-GetHashCode   <br />{    <br />&#160;&#160;&#160; param ( [int] $count = $(throw &quot;Need a count&quot;) )    <br />&#160;&#160;&#160; &quot;public override int GetHashCode() {&quot;    <br />&#160;&#160;&#160; &quot;int code = 0;&quot;    <br />&#160;&#160;&#160; 0..($count-1) | %{ &quot;code += EqualityComparer&lt;T{0}&gt;.Default.GetHashCode(m_{1});&quot; -f $upperList[$_],$lowerList[$_] }    <br />&#160;&#160;&#160; &quot;return code;&quot;    <br />&#160;&#160;&#160; &quot;}&quot;    <br />}</p>  <p>Both of the operators are likewise straight forward.&#160; As before mentioned <a href="http://msdn2.microsoft.com/en-us/library/ms132123.aspx">EqualityComparer&lt;T&gt;</a> will properly check for null and then perform an Equals call so it can be used as the standard operator code.&#160; </p>  <p>function script:Gen-OpEquals   <br />{    <br />&#160;&#160;&#160; param ( [int] $count = $(throw &quot;Need a count&quot;) )    <br />&#160;&#160;&#160; $OFS = ','    <br />&#160;&#160;&#160; $gen = &quot;&lt;&quot; + [string](0..($count-1) | %{ &quot;T&quot;+$upperList[$_] }) + &quot;&gt;&quot;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; &quot;public static bool operator==(Tuple$gen left, Tuple$gen right) {&quot;    <br />&#160;&#160;&#160; &quot;return EqualityComparer&lt;Tuple$gen&gt;.Default.Equals(left,right); }&quot;    <br />&#160;&#160;&#160; &quot;public static bool operator!=(Tuple$gen left, Tuple$gen right) {&quot;    <br />&#160;&#160;&#160; &quot;return !EqualityComparer&lt;Tuple$gen&gt;.Default.Equals(left,right); }&quot;    <br />}</p>  <p>In addition to the methods, the Tuple class generation must be changed to implement IEquatable&lt;Tuple&lt;&gt;&gt;.&#160; </p>  <p>Some will notice that the implementation forces the equality comparison to be against a Tuple&lt;T&gt; vs an ITuple&lt;T&gt;.&#160; There are a couple of reasons for this. </p>  <ol>   <li>I have come up against specific scenarios where I wanted to compare Tuple&lt;T&gt; but not ITuple&lt;T&gt;.&#160; This is not saying they don't exist (they do).&#160; But I prefer to leave an implementation until I find a justification for implementing it.&#160; </li>    <li>By constraining to IEquatable&lt;Tuple&lt;T&gt;&gt; we are always comparing apples to apples.&#160; If you try and perform an Equals against ITuple&lt;TA&gt; you're leaving yourself open to comparing apples and oranges.&#160; Since ITuple&lt;TA,TB&gt; implements ITuple&lt;TA&gt; it is a valid target for the overload.&#160; This type of equality seems scenario dependent and as such I left it out for the time.&#160; Note with our current implementation it would be very easy to come back and add this later.</li>    <li>To make #2 even stranger, once MutableTuples are implemented an implemantation of IEquatable&lt;ITuple&lt;TA&gt;&gt; might actually be comparing Tuple&lt;TA,TB,TC&gt; to MutableTuple&lt;TA&gt;.&#160; </li> </ol></div>
    