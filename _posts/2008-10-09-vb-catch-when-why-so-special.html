<P>The VB Catch syntax has a particular feature not present in C#: When.&nbsp; It allows users to filter expressions based on something other than their type.&nbsp; Any arbitrary code can enter a When block to decide whether or not to handle an Exception</P><PRE class=code>    <SPAN style="COLOR: blue">Sub </SPAN>Sub1()
        <SPAN style="COLOR: blue">Try
            </SPAN>DoSomeAction()
        <SPAN style="COLOR: blue">Catch </SPAN>ex <SPAN style="COLOR: blue">As </SPAN>Exception <SPAN style="COLOR: blue">When </SPAN>Filter(ex)
            <SPAN style="COLOR: blue">Stop
        End Try
    End Sub
</SPAN></PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>Newsgroups often ask, "Why's this so special? I could effectively get the same behavior out of C# by doing the following."</P><PRE class=code><SPAN style="COLOR: blue">static void </SPAN>Sub1()
{
    <SPAN style="COLOR: blue">try
    </SPAN>{
        DoSomeAction();
    }
    <SPAN style="COLOR: blue">catch </SPAN>(<SPAN style="COLOR: #2b91af">Exception </SPAN>ex)
    {
        <SPAN style="COLOR: blue">if </SPAN>(Filter(ex))
        {
            <SPAN style="COLOR: blue">throw</SPAN>;
        }
        HandleException();
    }
}</PRE><A href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></A>
<P>This is true to an extent.&nbsp; In both cases the code is handling an exception and making a decision, via calling Filter, as to whether or not to handle the exception.&nbsp; The subtle difference is when the Filter method is called.&nbsp; </P>
<P>In VB the When statement is actually implemented as an IL exception filter.&nbsp; When an exception is thrown, exception filters are processed before the stack is unwound.&nbsp; This means that if the Filter method created an error report that included the current stack trace, it would show the frame in which the exception occurred.&nbsp; </P>
<P>For example, in the code above if DoSomeAction() threw and the stack was examined in the Filter expression, the following stack would show up. </P>
<P><A href="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_2.png" mce_href="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_2.png"><IMG style="BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; BORDER-TOP: 0px; BORDER-RIGHT: 0px" border=0 alt=image src="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_thumb.png" width=504 height=304 mce_src="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_thumb.png"></A> </P>
<P>Notice how the DoSomeAction method is clearly visible?&nbsp; This is incredibly powerful for features like error reporting and investigation.&nbsp; It also allows you to set powerful breakpoints where the exact state of the error can be examined and not just the post mortem.&nbsp; </P>
<P>Alternatively, code executed in the C# block will occur after the stack is unwound.&nbsp; This gets rid of the culprit.&nbsp; As long as your not in optimized code you can usually use the stack trace properties to get the source of the exception but you won't be able to examine the live state of the error. </P>
<P><A href="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_4.png" mce_href="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_4.png"><IMG style="BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; BORDER-TOP: 0px; BORDER-RIGHT: 0px" border=0 alt=image src="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_thumb_1.png" width=501 height=304 mce_src="http://blogs.msdn.com/blogfiles/jaredpar/WindowsLiveWriter/VBCatch.WhenWhysospecial_1299E/image_thumb_1.png"></A></P></div>
    