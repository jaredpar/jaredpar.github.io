<p>Besides waiting, the another important issue when dealing with Futures is how to deal with exceptions thrown by the user specified code.&#160; </p>  <p><strong>Option 1: Ignore the Exception</strong></p>  <p>Don't take any actions in the future code and force users to write exception free code.&#160; IMHO this is not the best way to approach the problem.&#160; The code will be running in the thread pool and unhandled exceptions in the thread pool result in the taking down of an appdomain/process.&#160; In addition Futures are designed to be simple.&#160; Adding a try/catch around every lambda is not practical and/or readable.&#160; </p>  <p><strong>Option 2: Catch and Swallow</strong></p>  <p>Catch the exception on the background thread and swallow it.&#160; Silently failing is in many cases worse than actually crashing.&#160; Behavior will become flaky and the user/developer won't have any indication there is an error.</p>  <p><strong>Option 3: Re-throw the Exception when Wait is called</strong></p>  <p>Catch and save the exception when it occurs on the background thread.&#160; Then when Wait() is called on a Future re-throw the exception.&#160; This makes exception handled deterministic.</p>  <p>It's also very similar to the exception handling semantics of calling a method.&#160; The only difference is that users must handle the exception at the point of method completion vs invocation.&#160; For synchronous methods this is just the same point.</p>  <p>The big downside to this approach is the stack trace information is lost from the exception.&#160; Re-throwing will instead add the stack trace at the point of the re-throw.&#160; Not having stack trace information makes it very difficult to actually track down the source of an error.</p>  <p><strong>Option 4: Re-throw a new Exception when Wait is called </strong></p>  <p>This is very similar to Option #3.&#160; The only difference is when the user calls Wait, throw a new exception and make the original exception an inner exception of the new one.&#160; We'll call this exception FutureException.&#160; This has the advantages of option 3 and in addition will preserve the stack trace information from the original exception.</p>  <p>There is a downside to this approach though.&#160; Users can no longer have different catch blocks to handle the different types of exceptions that can be thrown.&#160; </p>  <pre class="code">            <span style="color: rgb(0,0,255)">try
</span>            {
                <span style="color: rgb(43,145,175)">Future</span>.Create(() =&gt; SomeOperation());
            }
            <span style="color: rgb(0,0,255)">catch</span> (<span style="color: rgb(43,145,175)">IOException</span> ex)
            {
                <span style="color: rgb(0,128,0)">// ...
</span>            }
            <span style="color: rgb(0,0,255)">catch</span> (<span style="color: rgb(43,145,175)">InvalidOperationException</span> ex)
            {
                <span style="color: rgb(0,128,0)">// ...
</span>            }</pre>

<p><a href="http://11011.net/software/vspaste"></a>Instead the user can only catch a Future exception and examine the inner result to take corrective action.&#160; </p>

<pre class="code">            <span style="color: rgb(0,0,255)">try
</span>            {
                <span style="color: rgb(43,145,175)">Future</span>.Create(() =&gt; SomeOperation());
            }
            <span style="color: rgb(0,0,255)">catch</span> (<span style="color: rgb(43,145,175)">FutureException</span> ex)
            {
                <span style="color: rgb(0,0,255)">var</span> type = ex.InnerException.GetType();
                <span style="color: rgb(0,0,255)">if</span> (type == <span style="color: rgb(0,0,255)">typeof</span>(<span style="color: rgb(43,145,175)">IOException</span>))
                {
                    <span style="color: rgb(0,128,0)">// ...
</span>                }
                <span style="color: rgb(0,0,255)">else</span> <span style="color: rgb(0,0,255)">if</span> (type == <span style="color: rgb(0,0,255)">typeof</span>(<span style="color: rgb(43,145,175)">InvalidOperationException</span>))
                {
                    <span style="color: rgb(0,128,0)">// ...
</span>                }
            }</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>This doesn't actually limit any functionality but users may find the syntax uncomfortable.&#160; VB users can still do exception filtering but this is not at option for C# users.&#160; </p>

<pre class="code">        <span style="color: rgb(0,0,255)">Try
</span>            Future.Create(<span style="color: rgb(0,0,255)">Function</span>() SomeOperation())
        <span style="color: rgb(0,0,255)">Catch</span> ex <span style="color: rgb(0,0,255)">As</span> Exception <span style="color: rgb(0,0,255)">When</span> ex.InnerException.GetType() <span style="color: rgb(0,0,255)">Is</span> <span style="color: rgb(0,0,255)">GetType</span>(IOException)

        <span style="color: rgb(0,0,255)">End</span> <span style="color: rgb(0,0,255)">Try</span></pre>

<p>The FutureException class is straight forward.&#160; A simple implementation of the exception snippet will do the trick. </p>

<pre class="code">    [<span style="color: rgb(0,0,255)">global</span>::System.<span style="color: rgb(43,145,175)">Serializable</span>]
    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">FutureException</span> : <span style="color: rgb(43,145,175)">Exception
</span>    {


        <span style="color: rgb(0,0,255)">public</span> FutureException() { }
        <span style="color: rgb(0,0,255)">public</span> FutureException(<span style="color: rgb(0,0,255)">string</span> message) : <span style="color: rgb(0,0,255)">base</span>(message) { }
        <span style="color: rgb(0,0,255)">public</span> FutureException(<span style="color: rgb(0,0,255)">string</span> message, <span style="color: rgb(43,145,175)">Exception</span> inner) : <span style="color: rgb(0,0,255)">base</span>(message, inner) { }
        <span style="color: rgb(0,0,255)">protected</span> FutureException(
          System.Runtime.Serialization.<span style="color: rgb(43,145,175)">SerializationInfo</span> info,
          System.Runtime.Serialization.<span style="color: rgb(43,145,175)">StreamingContext</span> context)
            : <span style="color: rgb(0,0,255)">base</span>(info, context) { }
    }</pre>
<a href="http://11011.net/software/vspaste"></a></div>
    