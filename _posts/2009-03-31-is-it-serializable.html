<p>I’ve recently run across several APIs that have a dependency on only dealing with objects that are serializable (in the binary sense).&#160; Unfortunately determining if an object is serializable is a non-trivial task and rife with problems.&#160; These problems have a direct impact on the types of guarantees these APIs can make.</p>  <p>For all objects which are serializable, it’s only possible to prove that a very small subset of them actually are in code.&#160; Easier but less reliable tests are very easy to write.&#160; So APIs must make a trade off.&#160; Only accept instances of types which are provable serializable and miss out on a while class of objects.&#160; Or do a much less reliable check and open themselves up to failure further down in the algorithm.</p>  <p>Take System.Exception for example.&#160; It is possible to associate arbitrary data with an exception through the <a href="http://msdn.microsoft.com/en-us/library/system.exception.data.aspx">Data</a> property.&#160; Associated just any object with Exception is problematic though because Exceptions <a href="http://winterdom.com/weblog/2007/01/16/MakeExceptionClassesSerializable.aspx">should be serializable</a>.&#160; In order for an Exception instance to store these objects and remain serializable, the objects must also be serializable.&#160; Since serializability is not provable, the authors of Exception had to make a trade off between an overly restrictive test, or a loose test.&#160; They chose the latter.&#160; As a result it’s impossible to determine before hand if a given Exception instance is actually serializable.&#160; </p>  <p>Why is this the case though that serialization is tough to determine?&#160; Lets start with what it takes to make a type serializable.&#160; There are two separate components</p>  <ol>   <li>Declaring that the type is Serializable by either having the SerializableAttribute on the class definition or by implementing ISerializable </li>    <li>Making the type conform to the rules of serialization.&#160; </li> </ol>  <p>These are completely separate actions.&#160; It’s possible to have types which do any combination of the above but not both.&#160; Take for instance the following type declarations</p>  <pre class="code">[<span style="color: #2b91af">Serializable</span>]
<span style="color: blue">class </span><span style="color: #2b91af">DeclaredOnly </span>{
    <span style="color: blue">private </span><span style="color: #2b91af">ConformsOnly </span>m_conforms;
}

<span style="color: blue">class </span><span style="color: #2b91af">ConformsOnly </span>{
    <span style="color: blue">private string </span>m_name;
}</pre>

<p>Both of these types are legal C# code and both represent one of the two extremes listed above.&#160; Yet neither of these types are actually serializable.&#160; ConformsOnly is not because it has not actually declared itself to be serializable.&#160; DeclaredOnly is not because one of it’s members is not serializable.&#160; </p>

<p>Lets look at proving serialization by ensuring types follow both of the rules.&#160; Proving the first part of serialization is pretty straight forward.&#160; Simply check to see if a type implements ISerializable or is decorated with the Serialization attribute.&#160; The latter is directly supported in the type system via <a href="http://msdn.microsoft.com/en-us/library/system.type.isserializable.aspx">Type.IsSerializable</a>.&#160; This property is also the source of the most common mistake I see with respect to determining if an object is serializable.&#160; Take the following code snippet for an example.</p>

<p><span style="color: blue">public static void</span>Example1(<span style="color: blue">object </span>o) { 

  <br />&#160;&#160;&#160; <span style="color: blue">if</span>(o.GetType().IsSerializable) { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: green">// Do something different 
    <br />&#160;&#160; </span>} 

  <br />}</p>
<a href="http://11011.net/software/vspaste"></a>

<p>On the surface, this looks like reasonable code.&#160; But as we just pointed out, the property IsSerializable just determines the presence or absence of the Serializable attribute but nothing about the second part.&#160; A more descriptive attribute name would be IsSerializableAttributeDeclared.&#160; Yet many pieces of code attempt to equate this property with the ability to be serialized (A fun experiment here is to search for it’s use in Reflector)</p>

<p>Proving the second part involves two cases, types implementing ISerializable and types decorated with the Serializable attribute.&#160; Lets start with the attribute.&#160; Proving these is involved but a straight forward process.&#160; The type must …</p>

<ol>
  <li>Be decorated with the Serializable Attribute </li>

  <li>One of the following items must be true for every field at all points in the hierarchy 
    <ol>
      <li>It must be decorated with the NonSerializedAttribute </li>

      <li>The type of the field must be sealed and must conform to all of these rules </li>
    </ol>
  </li>
</ol>

<p>Instances of types which meet these guidelines will always be serializable.&#160; Not meeting these rules though does not exclude a type from serialization.&#160; There are several sets of types decorated with Serializable which are serializable and do not meet these rules. </p>

<p>Take for instance types that violate rule 2.2.&#160; By having a field whose type is not sealed, it is possible to construct a runtime instance which contains a value whose type is not serializable.&#160; The following type fits into this category.&#160; </p>

<pre class="code">[<span style="color: #2b91af">Serializable</span>]
<span style="color: blue">class </span><span style="color: #2b91af">OnlyKnownPerInstance </span>{
    <span style="color: blue">private object </span>m_field1;
}</pre>

<p>Whether or not an instance of this type is serializable depends on the value of m_field1.&#160; So the only way to prove it is serializable is to look at the runtime information.&#160; This makes any definitive analysis on the type impossible.&#160; The actual object must be inspected.</p>

<p>The other case to examine are types implementing ISerializable.&#160; Serialization is a custom task for instances of these types and is done in imperative code.&#160; Proving these types are serializable involves actual algorithm inspection and is beyond the scope of this blog post.&#160; But suffice to say, proving these are serializable is an order of magnitude more difficult. </p>

<p>Getting back to the crux of this article.&#160; What is the best way to determine if an object is serializable or not?&#160; Bottom line, there is no good way.&#160; The only 100% definitive way is to serialize the object and see if it succeeds or not.&#160; This is problematic because it is not future proof.&#160; It only tells you that the object <strong>was </strong>serializable.&#160; This is a very important distinction.&#160; It’s possible for the object to be mutated in a different state later on which will prevent it from being properly serializable.&#160; </p>

<p>If serialization of a parameter is very important to the semantics of an API this is the only way to ensure the semantics are not violated is to serialize the object immediately and store the binary data.&#160; Otherwise you can only make a loose guarantee that an attempt to serialize in the future will succeed.</p></div>
    