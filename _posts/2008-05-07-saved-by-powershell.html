<p>Recently I made a very large update to our code base.&#160; Our code base lacked a standard way of guarding entry and exit points into the various components.&#160; Having said guards is useful for error handling, tracing, reducing redundancy, etc ...&#160; The edit standardized our entry points by adding start/end macros to our entry point functions.&#160; In addition to other house keeping, the macros also created an HRESULT variable named &quot;hr&quot;.&#160; Example below. </p>  <pre>#define MY_ENTRY_GUARD() HRESULT hr
#define MY_ENTRY_EXIT() return hr</pre>

<p>Ran suites, everything passed, checked in.&#160; Then I got an email from another dev who spent some time tracking down a bug related to this check-in (sorry <a href="http://blogs.msdn.com/calvin_hsia/">Calvin</a>).&#160; He discovered one scenario my fix did not take into account.</p>

<pre>SomeMethod
{
  MY_ENTRY_GUARD();
  if ( somecondition ) {
    HRESULT hr = E_FAIL; // shadows the first hr
  }
  MY_ENTRY_EXIT(); // returns unmodified hr
}</pre>

<p>The double declaration of the variable &quot;hr&quot; is not an error or even a warning in C++.&#160; Instead the inner &quot;hr&quot; shadows the outer and hence the rest of the method doesn't update the &quot;hr&quot; which is actually returned.&#160; So now I had to find every place in this change where a nested hr was declared.&#160; Did I mention this edit was huge?&#160; Going through by hand would not only be time consuming, it would also be very error prone.&#160; </p>

<p>At first I considered parsing out the C++ and doing basic brace matching to look for shadowing &quot;hr&quot; variables.&#160; I ruled that out due to the amount of time I would need to invest in the script to take into account comments, string literals, etc ...&#160; Really I didn't need brace matching, I really just needed to know when I entered and left a method.&#160; Almost all C++ methods have their opening and closing braces on the first column.&#160; Writing a script to detect this is trivial.&#160; </p>

<p>Script took about 5 minutes to write and 10 to run in the code base.&#160; Saved me countless hours of error prone reviews.&#160; Thank you PowerShell.</p>

<p>Find-DoubleHr.ps1: </p>

<p>param ( $argFileName = $(throw &quot;Need a file name&quot;) ) </p>

<p>function Do-Work() { 
  <br />&#160;&#160;&#160; $i = 0 

  <br />&#160;&#160;&#160; foreach ( $line in (gc $argFileName) )&#160; { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; new-tuple &quot;Text&quot;,$line,&quot;LineNumber&quot;,$i 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $i++ 

  <br />&#160;&#160;&#160; } 

  <br />} </p>

<p>function Do-Parse() { 
  <br />&#160;&#160;&#160; begin { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $inMethod = $false 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenHresult = 0 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenMacro = 0 

  <br />&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160; process { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $tuple = $_ 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ( $inMethod ) { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; switch -regex ($tuple.Text) { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;^}&quot; { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $inMethod = $false 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ( ($seenHresult -ne 0 )-and ($seenMacro -ne 0) ) { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;Found a double {0},{1}&quot; -f $seenHResult,$seenMacro 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenHresult = 0 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenMacro = 0 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;.*MY_ENTRY_GUARD.*&quot; { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; write-debug (&quot;Macro: {0} &quot; -f $tuple.Text) 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenMacro = $tuple.LineNumber 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;HRESULT.*\Whr\W&quot; { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; write-debug (&quot;HResult: {0}&quot; -f $tuple.Text) 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $seenHresult = $tuple.LineNumber 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; elseif ( $tuple.Text -match &quot;^{&quot; ) { 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $inMethod = $true 

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } 

  <br />&#160;&#160;&#160; } 

  <br />} </p>

<p>&quot;Processing $argFileName&quot; 
  <br />Do-Work | Do-Parse </p></div>
    