<p>When using an API you must take care to understand not only what it returns, but also for how long the data returned will be valid.&#160; This is very important to consider because programs must make either be making decisions on valid and predictable data or have appropriate fallback mechanisms for failure.&#160; </p>  <p>I often find bugs because people assumed certain APIs were giving back data about the present or future, but in fact the were giving back information about the past or much shorter present.&#160; Part of the problem stems from the fact that API names are usually written in the present tense regardless of what point in time the data returned is valid.&#160; For example “Exists” instead of “Existed” or “DidExist”.&#160; The language of the API lulls developers into a false sense of security and leads to programming errors.&#160; </p>  <p>I like to think of these values as a question of when they are valid.&#160; For instance, the data is, was or will be valid. </p>  <ul>   <li>Will – The data return is valid now and will be valid for the remainder of the program.&#160; </li>    <li>Is – The data is valid now and will remain valid until the program or thread takes some action to alter the underlying data source. </li>    <li>Was – The data was valid at some point in the past but by the time the program receives the result it can no longer be relied upon to be valid. </li> </ul>  <p>Working with APIs in the “was” category are the trickiest.&#160; Because the data we are working with is volatile we must approach them in a different way in order to provide reliable programs.&#160; Most algorithms work by validating the present or future state of the system and then executing code with the expectation of success.&#160; When working with a “was” API, there is no way validate the state of system because it cannot provide reliable information about its present or future state.&#160; Instead we must execute the algorithm with the expectation of failure and spend our time considering how to account for these failures appropriately.&#160; Failure must be the expected case, and not the exception.</p>  <p>Working with “will” and “is” APIs is a bit easier.&#160; Each has a level of predictability and it’s possible to use program state to make reliable decisions and hence produce reliable results.</p>  <p>Lets add some substance to this conversation by considering these types of APIs and the ContainsKey method on various hashtable style collections.&#160; This API is often written in the present tense regardless of how long the data is actually valid.</p>  <p>A “will” API is the safest to work with because the data will always be valid.&#160; This API cannot be influenced by side effects.&#160; Hence the the programmer is free to think only about the algorithm at hand.&#160; These APIs are rare and are typically associated with purely immutable data structures.&#160; This is the main type of structure for which data does not ever change.&#160; For instance consider this set of calls</p>  <pre class="code"><span style="color: blue">var </span>name = <span style="color: #a31515">&quot;bob&quot;</span>;
<span style="color: #2b91af">ImmutableMap</span>&lt;<span style="color: blue">string</span>, <span style="color: #2b91af">Student</span>&gt; map = GetSomeImmutableMap();
<span style="color: blue">if </span>(map.ContainsKey(name)) {
    SomeOtherCall();
    <span style="color: blue">var </span>student = map[name];
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p><a href="http://11011.net/software/vspaste"></a>This call to the indexer will succeed no matter what.&#160; The structure cannot be changed irrespective of what actually happens in SomeOtherCall.&#160; The ContainsKey method already asserted the key was present in the hashtable.&#160; Because the structure is immutable this assertion will be valid for the remainder of the program and hence the indexer must succeed.</p>

<p>An “is” API is the most common type of API.&#160; It is generally associated with mutable structures completely within the control of the program / thread.&#160; The data will remain valid until it is explicitly, or much worse implicitly, invalidated by the user.&#160; In a well factored program it is possible to reason about these types of APIs but hidden side effects can get you into trouble.&#160; For instance consider the following code in the context of a single thread. </p>

<pre class="code"><span style="color: blue">var </span>name = <span style="color: #a31515">&quot;bob&quot;</span>;
<span style="color: #2b91af">Dictionary</span>&lt;<span style="color: blue">string</span>, <span style="color: #2b91af">Student</span>&gt; map = GetSomeDictionary();
<span style="color: blue">if </span>(map.ContainsKey(name)) {
    <span style="color: #2b91af">Console</span>.WriteLine(map[name]);
    SomeOtherCall();
    <span style="color: #2b91af">Console</span>.WriteLine(map[name]);
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p><a href="http://11011.net/software/vspaste"></a>The state of a Dictionary&lt;TKey,TValue&gt; structure is completely within the control of the program. As such the first call to Console.WriteLine will work fine.&#160; There is nothing which can alter the state of map between the call to ContainsKey and the actual accessing of the map in the first WriteLine call so the assertion is still valid.&#160; </p>

<p>However without knowing the hidden side effects of the SomeOtherCall API we cannot know the next call to WriteLine will succeed.&#160; It’s possible for SomeOtherCall to access the underlying Dictionary reference and Clear it thus making the next call fail.&#160; True a programmer must investigate this before writing the above code.&#160; But consider the opposite problem.&#160; I am the maintainer of SomeOtherCall and I get a bug assigned to me which necessitates clearing out that Dictionary.&#160; I must now consider everyone who calls me, directly or indirectly and consider if any of them have an implicit dependency on the state of the underlying Dictionary object.&#160; This can get very difficult in a large program. </p>

<p>As previously stated, a “was” API is the most dangerous type of API.&#160; They never give back data for which you can make a reliable decision about.&#160; These APIs are associated with a data source that is not completely in the control of the current thread or program.&#160; Thus it’s possible for the data source to be altered at any point in the execution of the program / thread.&#160; Threading is a prime example of this problem.</p>

<p>For an example, consider SynchronizedDictionary to be an implementation of Dictionary&lt;TKey,TValue&gt; which uses locks internally to prevent data corruption from reads / writes on multiple threads but provides no other synchronization capabilities .&#160; </p>
<a href="http://11011.net/software/vspaste"></a>

<pre class="code"><span style="color: blue">var </span>name = <span style="color: #a31515">&quot;bob&quot;</span>;
<span style="color: #2b91af">SynchronizedDictionary</span>&lt;<span style="color: blue">string</span>, <span style="color: #2b91af">Student</span>&gt; map = GetSomeSynchronizedDictionary();
<span style="color: blue">if </span>(map.ContainsKey(name)) {
    <span style="color: blue">var </span>student = map[name];
}</pre>
<a href="http://11011.net/software/vspaste"></a>

<p>In this example it’s possible for the call to map[name] to fail because another thread came through and cleared the collection in between the if statement and the call to map[name].&#160; The bug here is that the program was written as if ContainsKey gave information about the present or future but in fact only gave information about the past.&#160; This actual return of the API could be made clearer by simply altering the name of the API.&#160; A much more applicable name is “DidContainKey” or “DidAndMayStillContainKey”.&#160; This name is much more representative of the data returned and will hopefully give a developer pause before writing code like the above.&#160; </p>

<p>My personal pet peeve in this category is the file system and in particular <a href="http://msdn.microsoft.com/en-us/library/system.io.file.exists.aspx">File.Exists</a>.&#160; Notice how this name is written in the present tense indicating a successful return means the file is currently in existence.&#160; Lets ignore permissions for a minute[1] and consider only the files existence.&#160; Any program on the machine is at liberty to change the file system and can do so at any point in time.&#160; Even the user can affect the file system by doing some thing as simple as yanking out a USB thumb drive or stumbling over a network cable.&#160; Any of these operations can alter the state of the file system and hence invalidate the existence of a File with 0 action from your program.&#160; Hence File.Exists cannot ever reliably determine if a file exists, it can only determine that a file “did” exist at some point in the past and may exist at some point in the future.&#160; A more representative name would be File.DidExist, or File.DidAndMayStillExist.&#160; </p>

<p>So when designing your APIs, take care to consider the lifetime of the data when naming them.&#160; </p>

<p>[1] Once you consider permissions you find that even File.DidExist in not a representative name.&#160; It probably should be called File.DidExistAndHadSomeMeasureOfAccess.&#160; Yes, that’s a terrible name :(</p></div>
    