<p>Recently while making a bug fix to our selection tracking code I discovered an unexpected behavior with CComPtr&lt;T&gt; instances.&#160; The crux of the fix included creating a new tracking mechanism exposed via COM in the type ISelectionTracking.&#160; The old interface, lets call it IOldTracking, was a completely unrelated interface in terms of inheritance hierarchies.&#160; </p>  <p>As part of the fix I changed the type of a field (m_spTracking) from CComPtr&lt;IOldTracking&gt; to CComPtr&lt;ISelectionTracking&gt;.&#160; I searched for assignments of m_spTracking and converted them to call the new API I added as part of the fix.&#160; I didn’t search terribly hard because I was depending on the compiler to catch any places I missed.&#160; ISelectionTracking and IOldTracking are incompatible types so any places I missed will show up as compilation errors.&#160; </p>  <p>Or so I thought … </p>  <p>I made my fix, ran our core check-in suites without error, checked in and moved onto the next bug.&#160; A couple hours later one of our other devs emailed me and informed me my check-in was breaking our larger, slower, suite bed run because m_spTracking was NULL. After some quick debugging I found myself looking at the following chunk of code which was apparently NULL’ing out m_spTracking in the suite.</p>  <pre class="code">  CComPtr&lt;IOldTracking&gt; spOldTracking;
<span style="color: blue">  if </span>( SUCCEEDED(CreateOldSelectionTracking(&amp;spOldTracking)) ) {
    m_spTracking = spOldTracking;
  }
 </pre>
<a href="http://11011.net/software/vspaste"></a>

<p>Me and the other dev were quite shocked that this compiled at all.&#160; How is it possible to assign between CComPtr&lt;ISelectionTracking&gt; and CComPtr&lt;IOldTracking&gt;???&#160; My first thought was I must have accidentally used a CComQIPtr somewhere (quickly verified that was not the case).&#160; After a bit of searching we found the cause was one of the operater=&#160; instances available on CComPtr&lt;T&gt;.&#160; Here is the definition</p>

<pre class="code"><span style="color: blue">template </span>&lt;<span style="color: blue">typename </span>Q&gt;
T* <span style="color: blue">operator</span>=(_In_ <span style="color: blue">const </span>CComPtr&lt;Q&gt;&amp; lp) <span style="color: blue">throw</span>()
{
    <span style="color: blue">if</span>( !IsEqualObject(lp) )
    {
        <span style="color: blue">return static_cast</span>&lt;T*&gt;(AtlComQIPtrAssign((IUnknown**)&amp;p, lp, <span style="color: blue">__uuidof</span>(T)));
    }
    <span style="color: blue">return </span>*<span style="color: blue">this</span>;
}</pre>

<p>This templated operator allows for assignments between CComPtr instance no matter what the type is for the left and right side.&#160; The effect is that instead of doing compile type C++ type conversion rules, it will instead rely on runtime COM polymorphic assignment rules via IUnknown::QueryInterface.&#160; This moves assignment errors from compile time to runtime for unrelated interfaces.&#160; </p>

<p>This is further complicated because it only applies to assignment between CComPtr’s (and derived instances).&#160; If the right hand side of the assignment is a non-smart pointer, compile time C++ conversions will apply.&#160; To demonstrate …</p>

<pre class="code">        CComPtr&lt;ISelectionTracking&gt; spTracking;
        CComPtr&lt;IOldTracking&gt; spOld;
        ...
        spTracking = spOld;  <span style="color: green">// Fails at runtime
        </span>spTracking = (IOldTracking*)spOld;  <span style="color: green">// Compilation Error
</span></pre>

<p>What surprised me though was talking to other developers about this issue.&#160; Most agreed with me that this is a bug in CComPtr&lt;T&gt;, or at least very unexpected behavior.&#160; A surprising number though did not expect this behavior but still considered it acceptable.&#160; The difference comes down whether you view CComPtr&lt;T&gt; as a simple smart pointer responsible for AddRef/Release semantics or as that plus an enabler of QueryInterface style conversions.&#160; I personally view CComPtr&lt;T&gt; as a simple smart pointer with know real understanding of QueryInterface style conversions and CComQIPtr&lt;T&gt; as a smart pointer which respects QueryInterface style conversions.&#160;&#160; As such this behavior is completely unexpected.&#160; </p>

<p>The fix in this case was pretty straight forward (use the new API) but I was still worried about how to prevent this type of problem in the future.&#160; In particular how to get the failure back to a compile time error.&#160; In the end we settled on using a stripped down version of CComPtr we already had in our code base going forward called CComPtrEx.&#160; I’ve previously blogged about about the need for this type <a href="http://blogs.msdn.com/jaredpar/archive/2008/02/22/multiple-paths-to-iunknown.aspx">here</a>.&#160; It’s different from CComPtr in the following ways</p>

<ul>
  <li>Does not have the templated version of operator= and instead relies on compile time C++ conversions checks for assignment </li>

  <li>Allows for interfaces which have multiple paths to IUnknown (can cause a compile time error in CComPtr). </li>
</ul>

<p>Also for purposes of rigor, we temporarily commented out the CComPtr&lt;T&gt; operator, recompiled our code base and verified no new errors popped up.&#160; </p></div>
    