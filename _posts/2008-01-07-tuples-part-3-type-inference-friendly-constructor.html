<p><a href="http://blogs.msdn.com/jaredpar/archive/2008/01/04/tuples-part-2-basic-structure.aspx">Last time</a> we were left with a constructor that required us to explicitly specify generic parameters.&nbsp; This is not always easy or possible.&nbsp; We'll now alter the script to generate a constructor which utilizes type inference to create a Tuple.&nbsp; In addition, all tuples will use the same overloaded method making the creation uniform.&nbsp; </p> <p>The best way to use type inference to create a generic argument is through static methods.&nbsp; In C# and VB it's legal to define a non-generic class with the same name as a generic class.&nbsp; I tend to create a non-generic class with a static Create method that takes advantage of type inference.&nbsp; For tuples the method will look like the following. </p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">partial</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Tuple
</span>{
    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;TA&gt; Create&lt;TA&gt;(TA a)
    { 
        <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Tuple</span>&lt;TA&gt;(a); 
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>This allows us to write the following code.&nbsp; </p><pre class="code">            <span style="color: rgb(0,0,255)">var</span> tuple = <span style="color: rgb(43,145,175)">Tuple</span>.Create(<span style="color: rgb(163,21,21)">"foo"</span>);</pre>
<p>Partial classes are used because we will be generating one per Tuple class that we create.&nbsp; It's just easier to script it this way.&nbsp; </p>
<p>The method is very straight forward.&nbsp; We need one new additional string for the arguments to the constructor.&nbsp; It's created along the same line as the previous strings.&nbsp; </p>
<p>function script:Gen-InferenceConstructor <br>{ <br>&nbsp;&nbsp;&nbsp; param ( [int] $count = $(throw "Need a count") ) <br>&nbsp;&nbsp;&nbsp; $OFS = ',' <br>&nbsp;&nbsp;&nbsp; $gen = "&lt;" + [string](0..($count-1) | %{ "T"+$upperList[$_] }) + "&gt;"&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; $list = [string](0..$($count-1) | %{ "T{0} {1}" -f $upperList[$_],$lowerList[$_] }) <br>&nbsp;&nbsp;&nbsp; $argList = [string](0..$($count-1) | %{ $lowerList[$_] }) <br>&nbsp;&nbsp;&nbsp; "public partial class Tuple {" <br>&nbsp;&nbsp;&nbsp; "public static Tuple$gen Create$gen($list) { return new Tuple$gen($argList); } " <br>&nbsp;&nbsp;&nbsp; "}" <br>} </p>
<p>Now just add a call to this function in Get-Tuple and the code is now inference friendly.&nbsp; </p>
<p>Next up is defining an interface for tuples that will allow us to treat a Tuple&lt;2&gt; as a Tuple&lt;1&gt;.&nbsp; Both have an "A" property and should be able to be used in a generic way.&nbsp; </p></div>
    