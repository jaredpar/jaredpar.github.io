<p>As I&rsquo;ve developed <a href="https://github.com/jaredpar/VsVim/">VsVim</a> over the years I&rsquo;ve authored quite a few reusable Visual Studio components.&nbsp; For the last 6 months I&rsquo;ve had many of these factored out to a separate utility library and this last week I decided to publish them as a separate <a href="http://nuget.org/">NuGet</a> package.&nbsp; Even if no one else every uses the library I want to reuse the utilities in other projects I&rsquo;m working on and NuGet is the perfect distribution mechanism.&nbsp; For those interested I&rsquo;ll be blogging about these components and why I authored them in the coming weeks (hint: perf, perf and more perf).&nbsp;</p>
<p>I wanted to blog about my the rules I learned from this exercise because even as a seasoned extension author I hit a couple of very surprising problems along the way.&nbsp; Hopefully the lessons I learned will help out the next person to attempt this</p>
<h1>Utility libraries must be strongly named</h1>
<p>This is an unfortunate truth of authoring a utility library in Visual Studio.&nbsp; If you intend to ever release more than one version of a utility library then you must accept that there will be two extensions referencing different versions of your library in the same instance of Visual Studio.&nbsp; Unless the assemblies are signed the CLR will only load one version into the AppDomain.&nbsp; This means one extension will see the version it expects and the others won&rsquo;t.&nbsp; This would be disastrous if the newer version of the library had new MEF interfaces, features, etc &hellip;</p>
<p>Simply being very diligent with version numbers just isn&rsquo;t enough here.&nbsp; When comparing a DLL reference to a DLL loaded in memory the CLR will ignore version numbers on unsigned assemblies [1].&nbsp; If an app has a reference to MyUtility.dll at Version 99 and MyUtility.dll at Version 1 is loaded the CLR will consider it a match.&nbsp; There&rsquo;s nothing I&rsquo;m aware of, other than strong names, that will change this behavior.</p>
<p>This also means you can&rsquo;t even rely on the latest version of your utility library being loaded.&nbsp; Extension load order is not defined in Visual Studio [2].&nbsp;&nbsp; Hence it&rsquo;s quite possible that extension referencing the oldest version of your utility library loads first and establishes that version as the one every other extension will use.&nbsp;</p>
<p>When an assembly is strongly named the CLR will respect version numbers and load multiple versions of the assembly into the AppDomain at the same time.&nbsp; Every extension will then see the version they are expecting independent of what other extensions are installed on the machine.&nbsp;</p>
<h1>MEF isn&rsquo;t version safe by default</h1>
<p>MEF gives the appearance of being a model that deals in terms of types.&nbsp; Contracts are typically defined in terms of interfaces, [Export] of the implementation use a typeof experession and the associated [Import] is tagged on a type location.&nbsp; Everything about it screams Type, yet MEF doesn&rsquo;t actually deal in terms of types, it primarily deals in terms of strings.&nbsp; Specifically in the form of a contract name and type name.&nbsp;</p>
<p>Every export and import have a contract name and type name associated with them.&nbsp; Only when both the contract name and type name match does MEF consider an Import and Export to match.&nbsp; Consider:</p>
<pre class="code">[<span style="color: #2b91af;">Export</span>(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">IObjectCache</span>))]
<span style="color: blue;">internal sealed class </span><span style="color: #2b91af;">ObjectCache </span>: <span style="color: #2b91af;">IObjectCache </span>{

}

</pre>
<p>The above code did not create an export of the .Net type IObjectCache or even it&rsquo;s assembly qualified name.&nbsp; Instead it created an export with</p>
<ul>
<li>Contract Name: SomeNamespace.IObjectCache</li>
<li>Type Name: SomeNamespace.IObjectCache</li>
</ul>
<p>Note: If you don&rsquo;t specify a contract name explicitly MEF will just reuse the type name it generates</p>
<p>Notice that no assembly information is captured in this export.&nbsp; It&rsquo;s just a type name plus the enclosing namespace.&nbsp; This contract will match up with any other Export of a type with the same fully qualified name as IObjectCache in any assembly loaded into the AppDomain.&nbsp; And this is <strong>exactly</strong> what will happen if you have multiple versions of your library loaded into the Visual Studio process [3]</p>
<p>In order to have version same MEF components the export and import contracts need to be different for different versions of your library.&nbsp; The easiest way to achieve this is to embed the assembly version into the contract name portion of an Export and Import.&nbsp; In my projects I achieve this by means of a constant which I reuse in my AssemblyVersion attribute and Exports</p>
<pre class="code"><span style="color: blue;">public static class </span><span style="color: #2b91af;">Constants </span>{
    <span style="color: blue;">public const string </span>AssemblyVersion = <span style="color: #a31515;">"1.0.0.0"</span>;
    <span style="color: blue;">public const string </span>ContractName = <span style="color: #a31515;">"MyUtility " </span>+ AssemblyVersion;
}

[<span style="color: #2b91af;">Export</span>(<span style="color: #2b91af;">Constants</span>.ContractName, <span style="color: blue;">typeof</span>(<span style="color: #2b91af;">IObjectCache</span>))]
<span style="color: blue;">internal sealed class </span><span style="color: #2b91af;">ObjectCache </span>: <span style="color: #2b91af;">IObjectCache </span>{

}

[<span style="color: blue;">assembly</span>: AssemblyVersion(<span style="color: #2b91af;">Constants</span>.ContractName)]

</pre>
<p>Unfortunately this messiness isn&rsquo;t something that can be self contained within your library.&nbsp; It&rsquo;s a price you must push down to your consumers as well.&nbsp; Their [Import] attributes must have the same contract name else MEF won&rsquo;t consider them a match and will reject the composition.&nbsp; Hence consumers of your library must use a similar pattern.&nbsp;</p>
<pre class="code"><span style="color: blue;">public class </span><span style="color: #2b91af;">MyService </span>{
    [<span style="color: #2b91af;">ImportingConstructor</span>]
    <span style="color: blue;">public </span>MyService([<span style="color: #2b91af;">Import</span>(<span style="color: #2b91af;">Constants</span>.ContractName)] <span style="color: #2b91af;">IObjectCache </span>objectCache)
    {

    }
}

</pre>
<p>This applies to all ImportingConstructor, Import and ImportMany usage of your types.&nbsp;</p>
<p>Both of these lessons set me back quite a bit.&nbsp; But eventually I was able to produce the <a href="https://nuget.org/packages/EditorUtils">EditorUtils</a> package I&rsquo;d been working on and change <a href="https://github.com/jaredpar/VsVim/tree/nuget">VsVim</a> to use it.&nbsp; Hopefully there aren&rsquo;t many more surprises waiting for me around the corner &hellip; <img class="wlEmoticon wlEmoticon-smile" alt="Smile" src="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-00-39-97-metablogapi/1452.wlEmoticon_2D00_smile_5F00_5E33E7BC.png" />&nbsp;</p>
<p>&nbsp;</p>
<p>[1] Except for Silverlight</p>
<p>[2] Unless there is an explicit entry in the manifest file declaring a dependency. Won&rsquo;t ever happen for unrelated extensions.</p>
<p>[3] If this surprises you then you&rsquo;re not alone. I frankly disbelieved the first person who told me this and had to create a sample app to prove it to myself</p><div style="clear:both;"></div></div>
    